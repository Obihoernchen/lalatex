#!/usr/bin/python
# -*- coding: utf-8 -*-
# See: PEP 0263
"""LaLaTeX Documentation tool

This tool creates a PDF document from a given source file in
a simple markup language format.
This source is converted into LaTeX code.
2015-12-06 - first beta 0.5.2 released to the team
2015-12-07 - main change: more safety in cleanup()
Ongoing changes: table improve (sort,per cell highlight,
                 offline data for RUN..., tarball)
"""

import re
import pdb
import pprint
import time
import subprocess
from optparse import OptionParser
import os
import pwd
from os.path import expanduser
import signal
import sys
#import platform
import hashlib
import shutil
#import string
import codecs
import tarfile
# the following turns out to be needed in python 2.6 in order
# to use the context manager protocol in combination with
# tarfile - TODO - check python version to decide .. ??
from contextlib import closing
import threading
from operator import itemgetter
import csv

__author__ = "Herbert Mehlhose"
__copyright__ = "Copyright 2015-2017, Herbert Mehlhose"
__credits__ = ["Klaus Eckel"]
__license__ = "GPL"
__version__ = "0.6.1"
__maintainer__ = "Herbert Mehlhose"
# well, removed that email stuff...
__email__ = ""
__status__ = "Beta"

# USE THIS TO SUPPRESS DEVEL STATEMENTS WITHOUT CHANGING CODE
# Allows to run during development w/o always using --devel
showDevel = 0

# Testing for available package manager - do it by simply trying
# to import. This does detect, which package manager to use.
# By testing the python import, any missing python package is
# detected. See Fedora23 server missing rpm-python package in
# default installation.
# TODO - what about the option to skip any prereq checks and
#        run on your own risk? (e.g. --nocheck)
try:
    import rpm
    pkgMgr = 'rpm'
except:
    rpm = None
    try:
        import apt
        pkgMgr = 'apt'
    except:
        print('Did not find "rpm" or "apt" package manager')
        print('You might be running on cygwin.. ??')
        print('Possible solution: try to install pkg "rpm-python"')
        print('or apt counterpart (python-apt) on debian based system')
        apt = None
        pkgMgr = None

# some variables (some might be good for a config file....)
author = 'Your Name'          # The default author
defLeftLogo = 'leftlogo.png'  # The default left logo
llxsubdir = 'lalatex-common'  # common subdir (in user home)
srcDefaultDir = 'listings'    # default for SRC bulk listings
tabDefaultDir = 'tables'      # default for TABB bulk tables
imgDefaultDir = 'images'      # default for images
wrkDefaultDir = 'workdata'    # default for offline data etc..
maxHeading = 5                # actually, never change this
defFont = 'r'                 # default font family
defFontSize = 4               # default font size
defImageSizeP = '18'          # default image width (portrait)
defImageSizeL = '25'          # default image width (landscape)
defTabFont = 's'              # default tab font family
defTabFontSize = 2            # default tab font size
defVrbFontSize = 3            # default verbatim font size
defCodFontSize = 2            # default code section font size
tabLineSep = '|||'            # table line separator
defHLight = {}                # default highlighting for tables
tabHLight = {}                # specific highlighting for tables
todoItems = []                # items collected by todo()
# This list is used to determine the needed texlive packages. Unfortunately,
# distros seem to deliver sometimes reduced texlive repositories, so that
# stuff needs to be searched manually, if pdflatex fails, or even is
# not available at all.
# Debian delivers a really FULL package - quite a lot of stuff, but works
# Also RHEL OpenClient seems to have all needed stuff available just
# by texlive-latex install.
# It's so ugly! e.g. centos - no watermark rpm (texlive-ncctools should
# provide this here, but it does also not work!)
# Currently thinking of removing the watermark feature if centos is
# detected
prereqs = {'rpm':                    ('texlive-latex',),
           'rpm-opensuse':           ('texlive-latex',
                                      'texlive-draftwatermark'),
           'rpm-centos':             ('texlive-latex',
                                      'texlive-texlive.infra',
                                      'texlive-latex-bin',
                                      'texlive-collection-latex',
                                      'texlive-ec',
                                      'texlive-lastpage',
                                      'texlive-titlesec',
                                      'texlive-ncctools',
                                      'texlive-framed'),
           'rpm-Fedora-workstation': ('texlive-latex',
                                      'texlive-latex-bin',
                                      'texlive-hyphen-german',
                                      'texlive-hyphen-english',
                                      'texlive-quotmark',
                                      'texlive-fancyhdr',
                                      'texlive-draftwatermark',
                                      'texlive-collection-langgerman',
                                      'texlive-lastpage',
                                      'texlive-titlesec',
                                      'texlive-framed',
                                      'texlive-ec',
                                      'texlive-babel-english',
                                      'texlive-draftwatermark'),
           'rpm-Fedora-server':      ('texlive-latex',
                                      'texlive-latex-bin',
                                      'texlive-hyphen-german',
                                      'texlive-hyphen-english',
                                      'texlive-quotmark',
                                      'texlive-fancyhdr',
                                      'texlive-draftwatermark',
                                      'texlive-collection-langgerman',
                                      'texlive-lastpage',
                                      'texlive-titlesec',
                                      'texlive-framed',
                                      'texlive-ec',
                                      'texlive-babel-english',
                                      'texlive-draftwatermark'),
           'apt':        ('texlive-full',)}
# Let's see, if we can reduce things a little bit... TODO
#                  'apt': ('texlive-latex-base',
#                          'texlive-latex-recommended',
#                          'texlive-latex-extra',
#                          'texlive-fonts-extra')

lalatexVersion = __version__         # LaLaTeX program Version string

# Valid colors for use in the document, important for table highlight
dviPsColors = ('Apricot', 'Aquamarine', 'Bittersweet', 'Black', 'Blue',
               'BlueGreen', 'BlueViolet', 'BrickRed', 'Brown', 'BurntOrange',
               'CadetBlue', 'CarnationPink', 'Cerulean', 'CornflowerBlue',
               'Cyan', 'Dandelion', 'DarkOrchid', 'Emerald', 'ForestGreen',
               'Fuchsia', 'Goldenrod', 'Gray', 'Green', 'GreenYellow',
               'JungleGreen', 'Lavender', 'LimeGreen', 'Magenta', 'Mahogany',
               'Maroon', 'Melon', 'MidnightBlue', 'Mulberry', 'NavyBlue',
               'OliveGreen', 'Orange', 'OrangeRed', 'Orchid', 'Peach',
               'Periwinkle', 'PineGreen', 'Plum', 'ProcessBlue', 'Purple',
               'RawSienna', 'Red', 'RedOrange', 'RedViolet', 'Rhodamine',
               'RoyalBlue', 'RoyalPurple', 'RubineRed', 'Salmon', 'SeaGreen',
               'Sepia', 'SkyBlue', 'SpringGreen', 'Tan', 'TealBlue', 'Thistle',
               'Turquoise', 'Violet', 'VioletRed', 'White', 'WildStrawberry',
               'Yellow', 'YellowGreen', 'YellowOrange')
stdColors = ('darkgreen', 'green', 'orange', 'blue', 'yellow', 'magenta',
             'red', 'cyan')


class hfcmDict(dict):
    def __missing__(self, key):
        value = self[key] = type(self)()
        return value

# llxStack: keeps all information for the current llx file that need
# to survive recursion in global space
llxStack = []
llxStack.append({'llx': '',
                 'llxBase': '',
                 'logName': '',
                 'llxLineNum': 0,
                 'llxTabCount': 0})
currentLtxFileName = ''

# $VAR - collect all variables defined - these are the interal readonly ones
vardict = {'LTXFILE': '',
           'LTXMASTER': '',
           'LALATEXVERSION': lalatexVersion}

# Font size information (e.g. used with verbatim, tables etc...)
fsize = ['\\tiny',
         '\scriptsize',
         '\\footnotesize',
         '\small',
         '\\normalsize',
         '\large',
         '\Large',
         '\LARGE',
         '\huge',
         '\Huge']
ffamily = {'s': '\sffamily',
           't': '\\ttfamily',
           'r': '\\rmfamily'}
verbPort = (161, 121, 109, 98, 89, 83, 69, 58, 48, 40)
verbLand = (224, 168, 151, 136, 124, 116, 96, 80, 67, 56)

defFontString = '\mdseries%s%s' % (ffamily[defFont], fsize[defFontSize])
docBody = ['%s\n' % defFontString]

# Self contained documentation for lalatex in lalatex syntax
# this is used when running lalatex --makedoc [--show] [--viewer]
lalaDoc = '''\
$$ The LaLaTeX self contained documentation in its own format.
$$ This file has been created by lalatex --makedoc.
$$
$TITLE$
$WATERMARK$ beta
$AUTH$
$VERS$
$CUST$ Users Guide
$PROJ$ LaLaTeX Documentation
$LEFTLOGO$
$CUSTLOGO$ client-logo.png
$$ Separator for multiple lines in table cells
$TSEP$ |||
$L$ LaLaTeX

$0$ darkgreen-OK
$1$ orange-president,sample
$2$ blue-
$3$ red-homeless

$MYVAR$ An often used productname

%%HST
%%HST

%%H1 Introduction#intro
LaLaTeX is meant as a simple tool to create documentation with easy syntax,
written in text source files of type i{.llx}. It compiles a simple set of easy
macros into LaTeX code. It should make documentation work easy. This means:
%%L1 Same appearance every time
%%L1 Defined logo for you (top left) and your customer (top right)
%%L1 Reduced set of features and therefore easy to use
%%L1 One run (no multiple runs as in LaTeX needed for index processing)
%%L1 Some more features, e.g. source code listings and data gathering
%%L1 Self contained documentation - c{lalatex --makedoc} creates this Users
Guide f{Note, that this intentionally produces warnings and errors when run}

If you like to do some really high sophisticated stuff, with full control over
all details of the final text layout, you'd better go for Latex.
%%H2 Running for the first time
Before starting, you create some test directory and copy in the lalatex
executable and the leftlogo.png. For the first time, you will most likely run
the program with no option or with the --help option. When running the program,
a subdirectory named p{lalatex-common} is created in your home directory.
The e{leftlogo.png} file is automatically copied into this directory,
so that it is available for any further projects from now on.
%%NP
The next step to do is to create the Users Guide PDF in your current directory
using the --makedoc option. You might have also chosen to create the
documentation in the first step. The common directory along with the move of
the logo picture is done in any case.
%%V3
lalatex --makedoc
%%V3
This creates the PDF file that your are currently reading. You can run this
as often as you like at any place. Note, that this produces some errors and
warnings, which are intended, as long as you do not get one of the following
messages:
%%V
- PDFLATEX ERROR >> !  ==> Fatal error occurred, no output PDF file produced!
- LaTeX timed out creating pdf file - maybe use longer timeout ...
%%V
%%TODO
Add a timeout example and check, why this is so much space between V and TODO
%%TODO
This would mean, that Latex could not process the generated .tex code, which
in this case means, that there are most likely missing packages on your
system. See r{trouble#} for more information.
%%TIP
Along with the PDF file for the documentation, --makedoc also creates a e{.llx}
and a e{.tex} file for this document. This e{.llx} file can be used as example
for lalatex code.
%%TIP
Creating a new documentation project is done by running the program with --new
option.
%%V3
lalatex --new <name_without_extension>
%%V3
The document files have the extension e{.llx}, that is not specified during
this call. The same happens as with --makedoc, but you get a smaller
documentation template generated, which you use as a starting point.
%%NL
Each time you create a new document, you can run --new to create a basic
skeleton file. The document document, your are currently reading is the self
contained documentation for LaLaTeX to show you all features by example.
It is created in a similar way, using option --makedoc instead of option --new.
%%TIP
Always create your document for a new project in a separate directory.
This is, because the program creates subdirectories for bulk includes like
listings.
%%NL
Creating a new project within the same directory works without problem, but if
you use any bulk includes, the same listings or tables could appear in both
projects. This might or might not be, what you intend.
%%TIP
%%H2 The .llx file header
After creating a new file, you will first edit it to include your specific
information. The following variables can be changed to your needs.
%%V3
 $TITLE$
 $WATERMARK$ draft
 $AUTH$
 $VERS$
 $CUST$ customer name
 $PROJ$ project name
 $LEFTLOGO$
 $CUSTLOGO$ client-logo.png
%%V3
This includes the e{TITLE} to be displayed on the cover page, the e{WATERMARK}
(see r{watermark#} for details), the e{AUTHor}, the document e{VERSion}, a
e{CUSTomer name}, a e{PROJect name} displayed on the top of each page, the
e{LEFTLOGO} to be displayed in the upper left and the e{CUSTLOGO} to be
displayed in the upper right of each page. If you leave LEFTLOGO empty, it
uses leftlogo.png as default. If you want to change the left logo, copy
another png file into your current directory or the p{$COMMONDIR$} directory
and provide the filename in the LEFTLOGO definition.
%%NL
The i{VERSion} must be defined in format i{nn[.n.n.n]}. The first digit(s) are
mandatory. Up to 2 digits are possible. The 3 other digits are optional.
%%NP
LaLaTeX tries to fill in the e{AUTH} statement automatically with your name
in the generated skeleton file. If this does not work for some reason (e.g.
you are running as root, which you actually should not do), the string
e{Your Name} is filled in and can be changed by you.
%%NP
Logo files are searched first in the specified path (if an absolute path has
been specified). If no absolute path is specified, it is first searched within
the current directory, then in the common directory,
p{"$COMMONDIR$"} f{If you change the sourcecode to a different subdir, \
regenerating the docu will update this path automatically}.
%%NP
If no picture is found for the customer logo, this is just replaced by the
string defined in CUST. For a missing left logo, a missing marker is displayed.
%%NL
In addition, the table highlighting can be defined here. The skeleton does
provide some default highlighting settings, that can be changed by you. The
format is as follows:
%%V
$n$ <color>-<keyword1>,<keyword2>
%%V
This allows to highlight table contents automatically.
See also the chapter r{tables#}.
The simplest way to compile your PDF is now:
%%V
lalatex <name>
%%V
Note, that you do not call the program using the .llx ending. If you do, a
warning is shown and LaLaTeX corrects this automatically.
%%H2 Document versioning
Document versions are defined by the c{VERS} statement in the header of your
llx file. After compiling the document, you will find the following in your
working directory.
%%V
<name>.llx
<name>-v<VERS>.llx
<name>-v<VERS>.tex
<name>-v<VERS>.pdf
<name>.bak
<name>.bk2
%%V
Here, e{<name>} is the name of the document, that you specified with --new.
The e{<name>.llx} file is your working copy. The other files are produced
by LaLaTeX, having e{<VERS>} in the name. This version string is taken from
the e{VERS} statement in the .llx header.
%%NP
If you create a new version, you just need to change i{VERS} in the header of
e{<name>.llx} and run the compiler again. The previous versioned files are
kept and new ones are created. You never should edit the versioned .llx copy
or run the program with the versioned one. Again, if you do, LaLaTeX detects
the version string and removes it, thus again using the working copy. Note,
that this overwrites changes, that you did in the versioned copy!
%%NP
The i{<name>.bak} file is a backup copy of your llx file. This gets written
after every i{successful} run of the program. If you destroy some content in
a way that breaks the Latex compiler run, this copy has the previous version
of your llx file available for comparison.
%%NL
The i{<name>.bk2} file is a backup copy created from tbe .bak file, so you
have an additional backup of one more generation available.
%%WARN
This does not protect you from changes like deletion of a chapter, which do
not make the compiler run fail. The .bk2 version helps you with one more
generation, so you can have one successful run and still have one previous
generation available.
%%WARN
%%H2 Command line options#options
The following table shows the available command line options. LaLaTeX does not
have any mandatory options.
%%TABH
SORTBY Parameter
Parameter;Short;Description
--help;-h;Display help
--new;-n;Create a new llx file and i{listings}, i{images} and i{tables} \
subdirectories f{No existing directories and contents are overwritten}
--makedoc;-m;Creates the document that you ar currently reading. Typically \
only run once.
--show;-s;Display the PDF file after creation
--viewer;;Select the PDF viewer, e.g. evince (default), acroread, okular
--verbose;-v;Display verbose information during execution
--version;-V;Display the program version
--debug;-d;Display debug information during execution
--timeout;-t;Force hanging processing to timeout after n seconds (default 45)
--keep;-k;Keep temporary files, which by default get deleted (for debugging)
--private;-p;Create a private copy, including PRIV and HIDE sections \
highlighted.
--unhide;;Include HIDE sections and remove any color highlighting
--history;;Create a document history entry within the llx file
--offline;-o;Use offline data without executing r{run#RUN} macros
--import;-i;Import a project dump
--export;-e;Export a project into a dump file
%%TAB
%%NOTE
This table has been intentionally defined without a caption to demonstrate the
highlighting of missing table captions in the resulting document, which also
appears in the List of Tables.
%%NOTE
%%H2 Document history#dochistory
The document history can be created by
%%V
lalatex <name> --history A comment to be added into the document
%%V
Each time you call the program with this parameter, a history entry is placed
above the table of contents, including the document version, date, author and
the added comment. See the history entry, that has been created as an example
in the PDF you are reading by running with option e{--makedoc}.
%%NL
You can remove any history entries from your .llx file. These entries are found
between the two c{HST} macros. Do NOT remove the HST statements themselves.
%%H2 Variables#vars
In addition to the predefined variables like $CUST$, $PROJ$, LaLaTeX allows to
define own user variables in format $VARNAME$. Variables can also be used in
the document content, for example to shorten product names, like i{$MYVAR}.
%%NL
This is done by using $VARNAME within the text. See the Users Guide llx
source for the example shown above. This also extends to included text. This
allows for example to use the i{CUST} variable in general text blocks, that
are included in multiple projects. The correct customer name is automatically
placed into the document, while using only one generic text block.
%%H2 Export and Import of projects
Since version 0.5.3.4, $L allows to export and import projects. This is done
by options c{--export} and c{--import}. When running lalatex with the --export
option, all data required to build the project are stored into a file which
is named i{lalatex-export-<projectdir>-YYYY-MM-DD-HH-MM-SS}.
%%NP
The recipient of the file just runs c{lalatex --import <filename>}. This import
creates the <projectdir> subdirectory within the current directory and also
handles any files, that are copied into i{lalatex-common}. If files already
exist, they will not be overwritten. For files, that have the same name but
different content, a collision warning is thrown.
%%H2 Dynamic data sources
Since version 0.5.3.4, $L allows to fill i{verbatim} and i{table} contents with
data gathered by commands via the c{%%RUN} macro. This for example allows to
generate the content of a table dynamically with 'live' data. See r{run#} for
more details.
%%H2 VIM Syntax Highlighting
A syntax highlighting is now available for $L, which simplifies editing a lot.
The vim definition files need to be installed into your environment first.
%%H1 Examples
This chapter shows the available features by example. A e{H1} section always
starts a new page.
%%H2 Comments
You can place comments into your source file at any place with 2 dollar signs
at the beginning of a line.
%%V
$$ This is a comment line within a .llx source
%%V
%%H2 Headings
Every document must start with a heading macro, otherwise an error is thrown.
Headings can be defined with 5 different levels from 1 to 5. This is done using
%%V3
%%Hn Title text#label
%%V3
where e{n} is the required heading level. An optional label can be defined for
all headings, which is used in references. See r{refs} for details on
references and labels. Using this scheme hides the section, subsection,
paragraph etc. stuff in LaTeX from you. Only the headings with levels H1, H2
and H3 show up in the e{Table of Contents}.
%%NP
In addition, a check is done for so called e{stacked headlines}. It is good
style to include text after each defined headline. Immediately entering a new
Hi{m} macro after another Hi{n} will cause a warning message about so called
e{stacked headings}. You might have noticed the warning for the stacked heading
during compiling this document that has intentionally been added as an example.
This also happens, if a chapter has just been left empty.
%%H3 Example Heading level 3
$$This is content in level 3 not visible
%%H4 Heading level 4 - a stacked heading example
This is content in level 4, but there is no text in between H3 and H4, which
causes a warning.
%%H5 Heading level 5
This is just an example of a heading level 5.
%%H2 Single character macros
You may e{emphasize text with bold and italic} or use b{bold text} or
i{italic text}. You can also u{underline} text. In addition, m{marked text}
is possible. This mechanism can also be used to create
e{footnotes} (see r{labfoot} for details). Commands within the documentation
can be marked by c{command} and pathnames like p{c:\path\\to\my\\file}. Also,
references are created using this mechanism. See chapter r{refs#} for details.
The following single character macros are available:
%%V3
b{bold text}
i{italic text}
e{emphasized text bold and italic}
u{underlined text}
m{marked text}
f{footnote text}
r{label}
p{pathname}
c{command}
%%V3
The command macro for example does avoid that double dashes like used in
options get converted to a so called n-dash. Example: c{command --option}. With
normal text, this is printed as i{command --option}.
%%NP
You are encouraged to use p{pathname}. Path names can become quite long,
and they are not well suited for hyphenation. Using the c{p}p option offers the
following advantages:
%%L1 Handling hyphenation (long pathnames do not run away to right text margin)
%%L1 Formatting to increase visibility
%%L1 Allow Microsoft Windows path names (evil backslash, see r{specialchar})

For example, p{C:\Users\herbert} as path name would fail in
LaTeX if used this way. The hyphenation can now additionally appear at each
path delimiter, either p{/} or p{\}. Latatex makes sure, that hyphenation will
not put in an annoying dash.
%%NOTE
Content between the brackets must be within one source line in the .llx file.
currently. You cannot use these macros nested. If using the above footnote
method, make sure, that the complete note fits into one single line of your
source file, or use c{%%FOOT} instead.
%%NOTE
%%H2 Special characters#specialchar
Handling special characters in \LaTeX might be tricky. The underscore and
backspace for example will not work by default. Lalatex handles this for you.
You can use _, \, { or } without escape, e.g. i{\}} and do not have to cope
with any problems.
%%H2 Page breaks, paragraphs and new lines
Adding new lines, paragraphs and page breaks is easy:
%%V3
%%NL  - creates new line
%%NP  - creates a paragraph (3pt space, 10pt indent)
%%BRK - inserts a page break
%%V3
%%H2 Lists
You can create lists (currently only single hierarchy with L[1] or Ln).
%%V3
%%L1 Text to be displayed in the list (type 1)
%%L  Another list item here, Using %%L defaults to unnumbered list item.

%%V3
Also, numbered lists are possible, using c{%%Ln}:
%%V3
%%Ln Text to be displayed in the numbered list
And we can continue a list item in a new line, so that text does not need to
fit into one single %%L line
%%Ln And a second list item in this numbered list.

%%V
A list is terminated by an empty line after the last element. Also, every
other non %%L macro following a list item terminates a list.
The above examples create the following lists:

%%L1 Text to be displayed in the list (type 1)
%%L  Another list item here, Using %%L defaults to unnumbered list item.

and
%%Ln Text to be displayed in the numbered list
And we can continue a list item in a new line, so that text must not be
fit into a single %%L line
%%Ln And a second list item here.
%%H2 Images
Images can simply be included by using the c{IMG} macro:
%%V3
%%IMGn <imagefilename>#<mandatory caption>#<optional label>
%%V3
The e{n} is the (optional) width in cm for the image in the document. If no
size is given, it is 18cm wide in i{portrait} and 25cm in
r{landscape#landscape}. The filename can contain spaces. The image is first
searched as given in the current directory or the specific path, if a path has
been specified. If it is not found at this location, LaLaTeX searches in the
e{images} subdirectory and finally in the e{lalatex-common} directory.
%%NL
As soon as you have an image in your document, a e{List of Figures} section is
created. The code has been tested to work with .png and .jpg files.
The following code
%%V
%%IMG12 nonexisting.png#My nonexisting picture#missingpicture
%%V
produces this error box in the document:
%%IMG12 nonexisting.png#My nonexisting picture#missingpicture
Because the image failed, no entry in list of figures is produced.
%%H2 Source code listings
You can include source code listings either as inline code snippets using
the c{CODE} macro or by the r{bulklist#} with the c{SRC} macro.
The inline code snippets can be added as follows:
%%V3
%%CODEn <language>#<Caption>#<optional label>
your code
%%CODE
%%V3
The fontsize is given by the number in CODEe{n}, which may be 0-9. Sizes are
the same as used in verbatim, see r{verb}. If no size is specified, size e{2}
is used. The following example
%%V3
%%CODE3 python#Some python code snippet#codelab
texOutFileName='%s.tex' % versionedFileName
with open ( texOutFileName, 'w+' ) as TEX:
    docHead = re.sub('\$PREAMBLE\$',preamble,docHead)
%%CODE
%%V3
produces the following output:
%%CODE3 python#Some python code snippet#codelab
texOutFileName='%s.tex' % versionedFileName
with open ( texOutFileName, 'w+' ) as TEX:
    docHead = re.sub('\$PREAMBLE\$',preamble,docHead)
%%CODE
For the e{Bulk listings} functionality, see r{bulklist}.
%%H2 Includes#inc
With the c{INC} macro, you can include any text you like from files. Also,
includes are possible within tables at any point. Search order: current
directory > tables > lalatex-common Table includes: you can comment lines
with $$ to exclude them. Comments may also be used for bulk includes to
create headings,captions,labels - e.g. getnodeinfo script can create such
headings. The $$ in non includes table rows just works as the lalatex comment
- and the row is skipped at that point.
%%NL
An important feature is, that you also can include other .llx files. This
allows to include prepared text blocks with complete chapters. The include
search order automatically searches in the following order:
%%TODO
Describe, also the feature that lalatex-common is searched with the subdir
if it is a relative path. This allows to have your text blocks within
lalatex-common subdirectories and you do not need to pass the full path.
%%TODO
Normally, you write .llx files for inclusion containing only markup text with
no informations like logo, author, appendix etc..., which cannot be compiled
standalone and only serve as text modules for reuse in multiple documents.
If you include 'full' .llx files, the following is skipped from included files
and instead now inherited from the main llx file:
%%L1 Any llx header infos like author, logo etc. are replaced by those in \
the main document
%%L1 Any history information contained in the included document is dropped
%%L1 Any LIT information in the included document is dropped
%%L1 The APP statement in the included document is skipped, and chapters \
within the appendix are included into the body of the main document.
%%L1 Highlighting definitions within tables are taken from the main document
%%H2 Tables#tables
You can create tables using the c{TAB} macro. After providing the macro with
some r{tabflags#optional flags}, enter the data in csv format (currenly only
with a semicolon as separator). You also can use c{INC} statements to include
contents from csv files at any place within the table section. Each table
section must end with a second c{TAB} macro starting on the next line.
%%NP
The first entered row is considered to contain the column descriptions and has
a light blue background color. All following rows in the table must fit this
same number of columns, regardless if entered manualy or taken from an include
file. LaLaTeX checks this and throws errors, if any column number mismatch
is found compared to the header.
%%NP
The following is a simple example, that also demonstrates the table highlight
and auto highlighting. Note the b{H} flag in the c{TAB} macro needed to
enable the automatic highlighting for a specific table.
%%V3
%%TABH Simple table with auto highlight#tablabel
Last Name;First Name;Remark;Status
Mehlhose;Herbert;This shows a sample entry in first line;OK
Beeblebrox;Zaphod;Get the 2{question}|||to the answer, see r{intro}; \
The president of the galaxy
Dent;Arthur;This 1{OK} has manually overwritten color;homeless
%%TAB
%%V3
Note the reference to label i{intro}, that has been included into the table.
More about references and labels is found in r{refs#}.
Also note the 3 pipes b{"|||"} which are used to produce a new line in the
table cell. Multiple lines in cells do not work in the table header line at
least for now. The above table source produces the following result:
%%TABH Simple table with auto highlight#tablabel
Last Name;First Name;Remark;Status
Mehlhose;Herbert;This shows a sample entry in first line;OK
Beeblebrox;Zaphod;Get the 2{question}|||to the answer, see r{intro};\
The president of the galaxy
Dent;Arthur;This 1{OK} has manually overwritten color;homeless
%%TAB
The above example table only uses the c{H} flag. Flags can just be added to
the c{TAB} statement in any order (no space between TAB and the flags). Flags
can change the following for table appearance:
%%L1 Font size from 0 to 9
%%L1 Font type (Roman, Sans Serif or Typewriter)
%%L1 Alternating Row coloring with c{A} flag or simple grid
%%L1 Auto highlighting using the c{H} flag

The auto highlighting is defined in the document header. This document uses
the follwowing definitions, that
have been activated for the above table by the e{H} flag:
%%V3
 $0$ darkgreen-OK
 $1$ orange-president,sample
 $2$ blue-
 $3$ red-homeless
%%V3
The format is to use a number of 0-9 within dollars, followed by a colorname.
The available colornames are predefined. See r{hlcolors} for a list with
examples. Then, after a dash, a comma separated list of keywords can be
specified. The keywords added here will be highlighted in the table with the
given color.
%%NP
This feature is useful if you want to track the status of objects in a table,
e.g. OK, failed or warning. In this case, the table gets automatically coloured
correctly. The skeleton produced by --new provides some defaults, which you can
adjust to your needs.
%%NL
In addition, the defined numbers can be used as e{single character macros} to
highlight text in a table. This has been done with the word e{question} in the
example table as follows:
%%V
Beeblebrox;Zaphod;Get the 2{question}|||to the answer, see r{intro}; \
The president of the galaxy
%%V
Note, that using an explicit highlighting overrides the auto highlight, as
shown by the orange b{OK} in the third table line. Auto highlight defines green
for the word OK, but it gets overwritten by the table source.
%%NL
It is possible to use the following flags within your table definition. The
next table shows the allowed flags and itself uses the b{A} flag to produce a
table with b{a}lternating row colours. Note, that the watermark gets
overwritten by coloured table rows. In addition, this table is at the same time
used to demonstrate the auto highlighting feature.
%%TABA Flags allowed with TAB statement#tabflags
Flag;description
0-9;The font size to be used, can be 0-9, as with other blocks
A;Table with alternating row colors and no horizontal lines (THIS table is an \
example)
H;Table with auto highlighting is created (OFF by default)
s;Using a sans serif font (the default)
t;Using a typewriter font
r;Using a roman font
%%TAB
By default, tables can span multiple pages. Continuations are marked in the
resulting document. The following table for demonstrating the table
highlighting colors at the same time is a real life example for a multi-page
table.
$SMPTAB$
By default, tables are scaled to fit the page width by expanding the last
column. In case, they are too wide, the last column gets a word wrap. This
might not be what you want. Consider using a smaller font or changing to
landscape format in this case.
%%NL
As soon as you have any tables in your document, a e{List of Tables} is
automatically created.
%%H2 Notes, Tips, Warnings and Todo's
Currently, you can use 4 different types of macros c{NOTE}, c{TIP}, c{WARN}
and c{TODO} to flag text sections. Within these, you also can use e{NL} for new
lines. The following code
%%V3
%%NOTE
This is an example c{NOTE}. Notes, tips and warnings can span multiple lines
and are marked by a thick colored line on the left. This shows an example for \
a newline within a note.
%%NL
The new line begins here. You also may e{emphasize} text, or use b{bold}
and i{italic} text within notes.
%%NOTE
%%V3
produces output marked by a color flag and a vertical line of the same color.
%%NOTE
This is an example c{NOTE}. Notes, tips and warnings can span multiple lines
and are marked by a thick colored line on the left. This shows an example for
a newline within a note.
%%NL
The new line continues here. You also may e{emphasize} text, or use b{bold}
and i{italic} text within notes.
%%NOTE
%%V
%%TIP
This is an example for a c{TIP}. The same rules apply for this as for notes.
%%TIP
%%V
produces the following output:
%%TIP
This is an example for a c{TIP}. The same rules apply for this as for notes.
%%TIP
%%V
%%WARN
This is an example for a c{WARN}. The same rules apply for this as for notes.
%%WARN
%%V
produces the following output:
%%WARN
This is an example for a c{WARN}. The same rules apply for this as for notes.
%%WARN
%%V
%%TODO
This is an example for a c{TODO}. The same rules apply for this as for notes.
%%TODO
%%V
produces the following output:
%%TODO
This is an example for a c{TODO}. The same rules apply for this as for notes.
%%TODO
%%H2 Verbatim sections#verb
Verbatim sections can be created by using the c{V} macro.
%%V
 %%Vn
 your content goes here
 %%Vn
%%V
The value of e{n} determines the font size, from tiny (0) to huge (9). The size
can be omitted, which results in the default size of 3. A second c{V} macro is
needed to end the verbatim section.
%%V0
This is V0 size
%%V0
The default V3 size looks as follows:
%%V3
This is V3 size with a text, that is too long to fit in one line. Lines, \
which are too long, are automatically wrapped and marked by an orange '\o>++' \
indicator at the end. In addition, \\rred++, \ggreen++, \\bblue++ and \
\oorange++ text is possible within verbatim sections.
%%V3
You can use r{inc#INC} to include files within a verbatim section. Everything
contained in the file is then shown as is, nothing gets interpreted. You also
can use r{run#RUN} within a verbatim section to get contents from the results
of the command.
%%NP
Colored text ist done by marking the text like e{\\r}text++. This prints
the word i{text} in red. The ++ acts as terminator. Use e{\g} for green, e{\\b}
for blue and e{\o} for orange. 
%%NL
Empty verbatim sections produce warnings and are marked as shown below:
%%V
%%V
This also includes blocks, which only contain empty lines.
%%H2 References and labels#refs
You can define labels and use them within references. This creates cross
references in the PDF file, that can be clicked. Labels are available for
%%L1 Heading sections
%%L1 Tables - here's the reference r{tablabel} to our sample table.
%%L1 Images
%%L1 Code listings (Inline r{codelab#CODE} and r{bulklist#})

Labels must use unique names. Note, that listings included by the bulklistings
function automatically get the label set to the filename. A reference to any
label is done by
%%V3
r{labelname}
r{labelname#optional replacement text}
r{labelname#}
%%V3
The first case creates default references in the style of r{tabflags}. If
an r{tabflags#optional replacement text} is specified separated by the hash
sign, the default reference text, e.g. "Chapter x.y" is replaced by this text.
This is useful, if for example commands are described in chapters. The
references can now print the command name instead, which is much nicer. For
example, a reference to the chapter about e{Private notes} can be referenced as
r{privnotes#PRIV}. When using the hash sign without specifiying a replacement
text, the caption text r{tabflags#} of the referenced object is printed.
%%NP
A working reference example: see r{tabflags} for a list of flags, that can be
used with tables. Any reference pointing to a non existing label is marked in
the resulting document, as shown with this invalid reference r{nonexist} as an
example. Non unique labels produce warnings as well, as shown in the Hyperlinks
chapter below, which has the same label named i{refs} as the current chapter
already uses. The first defined label i{wins}.
%%H2 Hyperlinks#refs
First of all, you find the i{dup label} warning. This is, because this chapter
has been assigned a duplicate label named i{refs}, which is already used for
the chapter r{refs#}. This is just to demonstrate this warning.
%%NL
Hyperlinks to websites can be produced by the c{HREF} macro
%%FOOT Make sure, that no space is contained in the URL, it should be %20, if \
you copy from your browser.
.
%%V3
%%HREF https://github.com/herb64 My github site address
%%V3
Click on
%%HREF https://github.com/herb64 My github site address
%%H2 Watermarks#watermark
You can define a watermark text within your llx file header. This creates a
watermark text in the document. To remove this, either specify e{none} as text,
specify nothing or delete the WATERMARK line completely. The best way is to
just use an empty string, so in case you want to add a watermark later on
again, the macro is still present. The watermark you see in this document is
created in the variables section at the beginning of this llx file.
%%V3
 $WATERMARK$ draft
%%V3
The current version always creates a new document by default with e{draft}
as watermark text.
%%H2 Footnotes#labfoot
Footnotes can be defined by using the c{FOOT} macro:
%%V3
%%FOOT This is my footnote
%%V3
The footnote here
%%FOOT This is my footnote
demonstrates, how this works. Another way f{Second alternative for footnotes \
is to use the f single character macro} is also possible.
%%H2 Private notes#privnotes
You can include private notices into your document using the c{PRIV} macro.
%%V3
%%PRIV
Here you add your private notices, only visible by --private option
%%PRIV
%%V3
A second c{PRIV} macro is always needed to close the section of private
content. The above code produces a section like the following:
%%PRIV
This has been created to show an example of a private notice. These notes will
only be included into the PDF file, if the --private option is specified. Note,
that --makedoc inplicitly creates the private sections for this documentation.
%%PRIV
%%H2 The RUN macro#run
This macro allows to collect data for i{verbatim sections} or i{tables} from
live data sources. It is a very powerful means of collection data for your
documentation. The syntax is
%%V
 %%RUN<t> <any command you like>
%%V
The i{t} is a timeout in seconds (default is 10 seconds, if not specified).
This is useful, if a data collection script is triggered by c{%%RUN}, which
might take some time to finish. Also, this timeout avoids hangs.
%%NL
For example
%%V
 %%V1
 %%RUN1 date && uname -a
 %%V
%%V
does run the date and uname commands live on the system and produces:
%%V1
%%RUN1 date && uname -a
%%V
This is only one example. This allows to run any data collection, including
queries on remote systems.
%%WARN
You should avoid any commands, that could cause damage, e.g. deleting any data.
%%WARN
The optional timeout value does cause $L to fail after an expiration of this
time. In this case, $L searches for any available offline content from a
successful previous run.
%%NP
$L keeps informations returned by RUN macros in the p{workdata} subdirectory.
If the command fails (for example, because you query data from an unavailable
remote system), $L tries to find the matching file from a previous successful
run of this command.
%%NP
Executing $L might cause delays due to the RUN timeouts. The c{--offline}
option allows to skip the RUN macros and directly searches for the offline
data. This requires, that these have been filled before.
%%H2 Hidden document parts
The c{%%HIDE} macro allows to mark parts of the document as hidden. This is
similar to the PRIV feature, but it allows to mark entire parts of an existing
document, including chapters, lists, tables etc.... These will be shown only,
if the --private flag is used (everthing is in a kind or red tone, except for
the headings) or if the r{options#--unhide} flag is used, in which case these
parts of the document are shown as normal.
%%V3
%%HIDE
%%H3 A hidden chapter
This is hidden text, which can include any other elements as well.
\\b...skip...++
%%NOTE
%%HIDE
%%V3
The above code shows a shortended source version of the hidden chapter below.
Note, that a second c{HIDE} statement is needed to close the hidden section. If
parts of the document are hidden, they do not appear in the Table Of Contents.
Note, that the page numbering and TOC therefore is different for a private or
public copy in the resulting PDF file.
%%NL
The following is an example of a hidden chapter. Note, that the heading is
displayed in black (also in the TOC). This could not yet be changed. All other
elements are in a coloured tone.
%%HIDE
%%H3 A hidden chapter
This is hidden text, which can include any other elements as well.
%%TABA Hidden Table
Name;Last Name
Mehlhose;Herbert
%%TABA
And also notes, tips etc. can be in hidden section.
%%NOTE
This is quite useful for an author to include parts in the document, that can
be easily removed later on.
%%NOTE
%%HIDE
%%H2 Landscape#landscape
You can change the format to landscape for special purposes as follows:
%%V3
%%LAND
%%H1 A title in landscape
All contents in between to LAND statementes are rendered in landscape...
%%LAND
%%V3
Note, that e{everything} contained in between 2 LAND macros is rendered in
landscape format, including headings. The granularity is on page level, so you
cannot have a H1 heading in portrait mode and on the rest of a page a table in
landscape. Landscape mode is useful for example for wider tables or images.
%%H2 Appendix#appmacro
An appendix is added by
%%V3
%%APP
%%V3
Within appendix, you can create different sections. All H1 sections after the
APP statement are not numbered any more. They use letters instead. An APP macro
must only entered once in the document. You also must enter a H1 heading
to make the appendix work properly.
%%H2 Literature
Literature lists can be included easily using e{LIT}.
%%V3
%%LIT
reference#Author#Title of document
%%LIT
%%V3
A reference is included as well as author and title.
$$
$$ Appendix
$$ By default, include all files here, which are contained in subdir 'listings'
$$
%%APP
%%H1 Bulk listings#bulklist
The script listings are included here if any scripts files are present within
the 'listings' subdirectory. You can use SRC macro for this. This should only
be used within the appendix, i.e. e{after} the r{appmacro#APP} macro,
otherwise a warning is shown. The following options exist:
%%L1 SRC without any parameters, which includes all source files within the
'listings' subdirectory
%%L1 SRC with a directory subtree, which includes all source files within this
subdirectory
%%L1 SRC with a specific filename
%%V
%%SRC
%%SRC <filename>
%%SRC <subdir>
%%SRC <subdir/filename>
%%V
No subdirectories are scanned. So either exactly contents of 'listings'
are used or contents of the exact directory tree you specifiy.
For each source file, a heading one level deeper than the current Heading
level is created, if possible. These headings are automatically labeled and
can be referenced by the filename. SRC checks the content of script files
to get the language for syntax highlighting. Currently known languages are
%%L1 python
%%L1 perl
%%L1 bash
%%L1 sh
%%L1 ksh

The SRC statement prints an information about the MD5SUM for the listing
files, which might be very useful later on. The following has been
completely automatically generated from the files found in the
e{listings} subdirectory.
%%NL
The listings included by the bulk listings feature can be referenced by
using the filename as labelname. For example
%%V
r{my-script.sh#}
%%V
%%H1 Problem solving
This chapter should help you with problems.
%%H2 Known issues
There are some known issues with the code. Some of them are listed here.
%%L1 Rare, but if the very last entry of a document is a list item, this
list is skipped. Workaround: add a NP statement, as in the source for this
documentation.
%%L1 Table numbering starts at 2, if history information is present.
This is, because internally, the history is actually a table as well.
%%L1 Single character macros, e.g. for textmarker, must be closed within the
same source line currently. Not a bug, but I think about ways to change this.
%%L1 If a watermark is present, the selection of text within the PDF file
does not work. Remove the watermark in this case. It seems to be internally
caused by the Latex package used for watermark creation.
%%L1 Multiline table cells are not available in the table header. If you
enter 3 pipe signs b{|||}, these will just be printed as is.
%%L1 Table auto highlight does not highlight elements within single char
macros, e.g. bold or italic is printed black.
%%L1 If using a reference within a heading that points to a non existent
label, this currently leads to PDFLATEX FATAL error. Root cause is known
just need to work on a fix.
%%L1 Umlaut i{ä,ö,ü,Ä,Ö,Ü} currently not allowed in marked (i{m{text}}) \
and underlined (i{u{text}}) sections. Partly caused by the soap package.
Error "i{Umlauts not allowed in macros "m" and "u", offending string: \
m{bad_text})}}" is displayed and program ends.
%%L1 Using curly brackets { or } within command macro c{c{}} currently
produces unwanted output, as you see here. Cause is detected, needs fix.
%%L1 Output from c{lsblk} or c{pstree} with those nice line drawings
cannot be used. Workaround: use c{lsblk -i} / c{pstree -A} instead.
%%H2 Troubleshooting#trouble
Normally, the tool will successfully come to an end and produce a PDF file.
Under certain circumstances, the produced .tex file might make the pdflatex
command fail. This can result in an error as shown in the following example,
that has been taken from first tests with Fedora 23.
%%V2
\\rERROR:++   PDFLATEX ERROR >> ! Package babel Error: Unknown option \
`ngerman'. Either you misspelled it
\\rERROR:++   PDFLATEX ERROR >> !  ==> Fatal error occurred, no output PDF \
file produced!
\\rERROR:++   LaTeX failed to create pdf file - see above error(s)
%%V
LaLaTeX tries to check the returned output from pdflatex for errors, which
worked in the above example. Unfortunately, in most cases, the pdflatex
command does not return more information and only the i{Fatal error occurred}
message is shown.
%%NP
Another issue can be, that the pdflatex command does not return at all,
although it is called with the halt-on-error function. This behaviour is
trapped by a timer in LaLaTeX and results in the following message:
%%V2
ERROR:   LaTeX timed out creating pdf file - maybe use longer timeout or \
"pdflatex" command is missing?
%%V2
By default, the timer is set to 45 seconds, and can be changed with the
c{--timeout} parameter. But 45 seconds was enough even for my largest
project with 280 pages and about 50 tables and pictures.
%%NL
There are some b{TODO} items left, some of them
%%L1 More toubleshooting documentation
%%L1 I'm planning to provide a quick reference card
%%L1 Current produced file is PDF only - add more options
%%L1 More languages for SRC listings
%%L1 Index and Glossary
%%L1 Adopt to run under Windows ??

%%NP
'''

# Skeleton for a new documentation project in lalatex syntax
# this is used when running lalatex --new <name>
lalaSkeleton = '''\
$$ Document skeleton initially generated by LaLaTeX V$LALATEX$ - do not \
change !
$$ Change the following variables to meet your needs.
$TITLE$ Title - replace with your title
$WATERMARK$ draft
$AUTH$
$VERS$ 0.1
$CUST$ Client Name
$PROJ$ project name
$LEFTLOGO$ leftlogo.png
$CUSTLOGO$ client-logo.png

$$ Table color highlighting with some presets - change as you need it
$0$ darkgreen-OK,UP
$1$ orange-WARN,UNKNOWN
$2$ red-BAD,FAILED
$3$ blue-

$$ You can also define your own variables, e.g. for product names and \
reference them
$$ by $<name> in your text. See the below DEMO variable and its use in this \
template.
$DEMO$ THE DEMO VARIABLE

$$ Do not remove these HST macros - the --history option places entries in \
between
$$ the HST macros. You can remove lines between the statements at any time.
%%HST
%%HST

$$ EDIT AS YOU LIKE BELOW THIS LINE

%%H1 Introduction#introlabel
Please fill in your contents here. The following mostly used macros
should help you as you proceed writing. Just remove the comments ($$) and
adjust to your needs. BTW, this m{$DEMO} is the defined variable above.
%%NL
Want to include your $CUST automatically? Done here, and it works within your
prepared text blocks for inclusion as well...
%%TIP
See the Users guide for many more details.
%%TIP

$$%%H2 title text#label

$$%%L list element 1
$$%%L list element 2

$$%%IMG img-filename#mandatory caption#optional label

$$%%TAB
$$head1;head2
$$content1;content2
$$%%TAB

$$%%V
$$the verbatim content to be shown
$$%%V

$$%%NOTE
$$The content for a note
$$%%NOTE

$$%%NL
$$%%BRK

$$ A P P E N D I X
$$ uncomment, if you use it. Make sure, that you include a H1 statement
$$ after the APP
$$%%APP
$$%%H1 Some title

$$ Bulk listings include from 'listings' subdirectory
$$ uncomment, if you use it
$$%%H1 Listings
$$%%SRC

$$ Literature entries example
$$ uncomment and fill if you use it
$$%%LIT
$$ref#Author#Title of doucment
$$%%LIT
'''

# Allow to include some watermark for "Draft" documents
watermark = '''\
\usepackage{draftwatermark}
\SetWatermarkText{TEXT}
\SetWatermarkScale{1}
'''

# docHead defines the LaTeX document header, including some variables
# that are automatically replaced
docHead = '''\
$PREAMBLE$
\documentclass[a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[ngerman,english]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage[colorlinks=true,linkcolor=black,urlcolor=href]{hyperref}
\usepackage{float}
\usepackage{color}
\usepackage{listings}
\usepackage{lastpage}
\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{titlesec}
\usepackage{caption}
\usepackage{filecontents}
\usepackage{ltxtable}
\usepackage{longtable}
\usepackage{colortbl}
\usepackage{lscape}
\usepackage[dvipsnames]{xcolor}
\usepackage{soul}
\usepackage{framed}
%%
\captionsetup{font={footnotesize,it}}
$WATERMARK$
\setcounter{secnumdepth}{5}
\\restylefloat{figure}
\pagestyle{fancy}
\hoffset-15mm
\\voffset-10mm
\\textwidth+180mm
\\textheight+250mm
\\fancyhfoffset[L]{5mm}
\\fancyhfoffset[R]{1cm}
\\restylefloat{figure}
\lhead{$LEFTLOGO$}
\chead{Project: $PROJ$}
\\rhead{$CUSTLOGO$}
\lfoot{$AUTH$}
\cfoot{Page \\thepage~of \pageref{LastPage}}
\\rfoot{Version $VERS$}
\\renewcommand{\headrulewidth}{2pt}
\\renewcommand{\\footrulewidth}{2pt}
\\restylefloat{table}
\\restylefloat{figure}
\\title{$TITLE$}
\\author{$AUTH$}
\date{$DATE$}
%% === Colors ===
\definecolor{comment}{rgb}{0.0,0.0,1.0}
\definecolor{variables}{rgb}{0.0,0.7,0.0}
\definecolor{keyword}{rgb}{0.8,0.8,0.3}
\definecolor{thead}{rgb}{0.66,0.66,1.0}
\definecolor{theadhidden}{rgb}{1.0,0.66,0.66}
\definecolor{theadbad}{rgb}{1.0,0.11,0.11}
\definecolor{texthidden}{rgb}{0.5,0.0,0.0}
\definecolor{lblue}{rgb}{0.95,0.95,1.0}
\definecolor{lred}{rgb}{1.0,0.95,0.95}
\definecolor{href}{rgb}{0.10,0.00,0.60}
\definecolor{hhref}{rgb}{0.60,0.00,0.40}
\definecolor{shadecolor}{rgb}{0.95,0.95,0.95}
\definecolor{priv}{rgb}{0.75,0.00,0.00}
\definecolor{htip}{rgb}{0.80,0.50,0.50}
\definecolor{hnote}{rgb}{0.80,0.50,0.50}
\definecolor{darkgreen}{rgb}{0.00,0.65,0.10}
\definecolor{cmdcolor}{rgb}{0.30,0.30,0.50}
\definecolor{hcmdcolor}{rgb}{0.60,0.30,0.30}
\lstset {
  basicstyle=\\ttfamily\\tiny,breaklines=true,
  commentstyle=\color{comment}\\ttfamily,
  keywordstyle=\color{keyword}\\ttfamily,
  stringstyle=\color{variables}\\ttfamily,
  tabsize=4,
  numbers=left,
  showspaces=false,
  showstringspaces=false,
  captionpos=b
}
%% === Stuff for hint boxes ===
\\newenvironment{note}{
  \def\FrameCommand##1{\\textcolor{gray}\
{\\vrule width 3pt} \hspace{10pt}##1}%
  \MakeFramed {\\advance\hsize-\width \FrameRestore}}%
 {\endMakeFramed}
\\newcommand*{\\NOTE}{\hspace{-25pt}\colorbox{gray}\
{\\textbf{\\textcolor{white}{ NOTE }}}}
\\newenvironment{hnote}{
  \def\FrameCommand##1{\\textcolor{hnote}\
{\\vrule width 3pt} \hspace{10pt}##1}%
  \MakeFramed {\\advance\hsize-\width \FrameRestore}}%
 {\endMakeFramed}
\\newcommand*{\\HNOTE}{\hspace{-25pt}\colorbox{hnote}\
{\\textbf{\\textcolor{white}{ NOTE }}}}
\\newenvironment{warn}{
  \def\FrameCommand##1{\\textcolor{orange}\
{\\vrule width 3pt} \hspace{10pt}##1}%
  \MakeFramed {\\advance\hsize-\width \FrameRestore}}%
 {\endMakeFramed}
\\newcommand*{\\WARN}{\hspace{-25pt}\colorbox{orange}\
{\\textbf{\\textcolor{white}{ WARNING }}}}
\\newenvironment{hwarn}{
  \def\FrameCommand##1{\\textcolor{hnote}\
{\\vrule width 3pt} \hspace{10pt}##1}%
  \MakeFramed {\\advance\hsize-\width \FrameRestore}}%
 {\endMakeFramed}
\\newcommand*{\\HWARN}{\hspace{-25pt}\colorbox{hnote}\
{\\textbf{\\textcolor{white}{ WARNING }}}}
\\newenvironment{tip}{
  \def\FrameCommand##1{\\textcolor{violet}\
{\\vrule width 3pt} \hspace{10pt}##1}%
  \MakeFramed {\\advance\hsize-\width \FrameRestore}}%
 {\endMakeFramed}
\\newcommand*{\\TIP}{\hspace{-25pt}\colorbox{violet}\
{\\textbf{\\textcolor{white}{ TIP }}}}
\\newenvironment{htip}{
  \def\FrameCommand##1{\\textcolor{hnote}\
{\\vrule width 3pt} \hspace{10pt}##1}%
  \MakeFramed {\\advance\hsize-\width \FrameRestore}}%
 {\endMakeFramed}
\\newcommand*{\\HTIP}{\hspace{-25pt}\colorbox{hnote}\
{\\textbf{\\textcolor{white}{ TIP }}}}
\\newenvironment{todo}{
  \def\FrameCommand##1{\\textcolor{red}\
{\\vrule width 3pt} \hspace{10pt}##1}%
  \MakeFramed {\\advance\hsize-\width \FrameRestore}}%
 {\endMakeFramed}
\\newcommand*{\\TODO}{\hspace{-25pt}\colorbox{red}\
{\\textbf{\\textcolor{white}{ TODO }}}}
\\newenvironment{htodo}{
  \def\FrameCommand##1{\\textcolor{hnote}\
{\\vrule width 3pt} \hspace{10pt}##1}%
  \MakeFramed {\\advance\hsize-\width \FrameRestore}}%
 {\endMakeFramed}
\\newcommand*{\\HTODO}{\hspace{-25pt}\colorbox{hnote}\
{\\textbf{\\textcolor{white}{ TODO }}}}
%% === ADD FOR PARAGRAPH HANDLING ===
\setlength{\parskip}{4pt}
\setlength{\parindent}{10pt}
%% === H0 ===
\setcounter{tocdepth}{3}
\\titleclass{\simple}{straight}[\subparagraph]
\\newcounter{simple}
\\renewcommand{\\thesimple}{\Alph{simple}}
\\titleformat{\simple}[runin]{\sffamily\\small\\bfseries}{\\thesimple}{1em}{}
\\titlespacing*{\simple} {0pt}{1.25ex plus 1ex minus .2ex}{1em}
%%
%% === Document starts here ===
%%
\\begin{document}
\maketitle
$DOCHISTORY$
\\tableofcontents
\listoffigures
\listoftables
%% === END OF DOCHEAD ===
'''

# A document history that can be shown on the title page
docHistory = []
docHistory.append('\sffamily\Large\\\\bfseries')
docHistory.append('\\\\noindent')
docHistory.append('Document history')
docHistory.append('\mdseries\\%s\\%s' % (ffamily[defFont], fsize[defFontSize]))


class TimeOutException(Exception):
    pass


class KillException(Exception):
    pass


class RUN(object):
    # subprocess.Popen has no timeout in python < 3.3 - use thread
    # constructor
    def __init__(self, runCmd):
        self.cmd = runCmd
        self.childProcess = None
        self.out = ''
        self.err = ''
        self.runFailed = None

    def run(self, timeout):
        def runProc():
            self.childProcess = subprocess.Popen(self.cmd, shell=True,
                                                 stdout=subprocess.PIPE,
                                                 stderr=subprocess.PIPE)
            self.out, self.err = self.childProcess.communicate()
            self.runFailed = self.childProcess.returncode

        thread = threading.Thread(target=runProc)
        thread.start()
        thread.join(timeout)
        # if thread still living after this timeout: we failed
        if thread.is_alive():
            #self.err='PROCESS TIMEOUT'
            self.childProcess.terminate()
            thread.join()
            return [self.runFailed, self.out, 'PROCESS TIMED OUT']
        else:
            return [self.runFailed, self.out, 'IN TIME']


def handler(signum, frame):
    # SIGALRM
    if (signum == 14):
        raise TimeOutException
    # SIGTERM
    if (signum == 15):
        raise KillException


def getOsRelease():
    """Get Release information

    This retrieves information of /etc/os-release (systemd based)
    """
    osRelease = {}
    releaseFile = '/etc/os-release'

    if os.path.exists(releaseFile):
        debug('%s detected, collecting information...' %
              releaseFile)
        with open(releaseFile, 'r') as REL:
            for line in REL:
                line = re.sub(r'\n', '', line)
                if line:
                    (key, value) = line.split('=', 1)
                    osRelease[key] = value
    else:
        # Well, no systemd provided os-release, so fill in variables by
        # using other sources (PRETTY_NAME currently)...
        debug('No "%s" detected, trying other methods...' % releaseFile)
        if os.path.exists('/etc/redhat-release'):
            debug('Redhat detected by /etc/redhat-release...')
            # has only one line
            with open('/etc/redhat-release', 'r') as REL:
                for line in REL:
                    osRelease['PRETTY_NAME'] = re.sub(r'\n', '', line)
        elif os.path.exists('/etc/SuSE-release'):
            debug('SuSE detected by /etc/SuSE-release...')
            # SuSE-release is deprecated, but for older systems.. here we go
            # Use only first line, Service Pack level is not read here...
            with open('/etc/SuSE-release', 'r') as REL:
                for line in REL:
                    osRelease['PRETTY_NAME'] = re.sub(r'\n', '', line)
                    break
        else:
            error('Was not able to detect the OS release')
    return osRelease


def info(string):
    """Print a INFO statement.
    """
    if options.debug or options.verbose:
        if llxStack[-1]['llxLineNum']:
            print('\033[1;34mINFO:   \033[0m (%s - line %d) %s' %
                  (llxStack[-1]['logName'],
                   llxStack[-1]['llxLineNum'],
                   string))
        else:
            print('\033[1;34mINFO:   \033[0m %s' % string)


def debug(string):
    """Print a DEBUG statement.
    """
    if options.debug:
        if llxStack[-1]['llxLineNum']:
            print('\033[95mDEBUG:  \033[0m (%s - line %d) %s' %
                  (llxStack[-1]['logName'],
                   llxStack[-1]['llxLineNum'],
                   string))
        else:
            print('\033[95mDEBUG:  \033[0m %s' % string)


def todo(string):
    """Print a TODO marker.
    """
    global todoItems
    if options.debug or options.devel:
        if not string in todoItems:
            todoItems.append(string)
            print('\033[92mTODO:    %s\033[0m ' % string)


def warn(string):
    """Print a WARNING statement.
    """
    if llxStack[-1]['llxLineNum']:
        print('\033[1;93mWARNING:\033[0m (%s - line %d) %s' %
              (llxStack[-1]['logName'], llxStack[-1]['llxLineNum'], string))
    else:
        print('\033[1;93mWARNING:\033[0m %s' % string)


def error(string):
    """Print an ERROR statement.
    """
    if llxStack[-1]['llxLineNum']:
        print('\033[1;91mERROR:  \033[0m (%s - line %d) %s' %
              (llxStack[-1]['logName'], llxStack[-1]['llxLineNum'], string))
    else:
        print('\033[1;91mERROR:  \033[0m %s' % string)


def devel(string, *arguments):
    """Print a DEVEL statement - meant for development purposes.

    THis is always printed, so no devel statements should be in final code!
    """
    # TODO - maybe a log file could be useful
    if not showDevel:
        return
    if llxStack[-1]['llxLineNum']:
        print('\033[1;30mDEVEL:   (%s - line %d) %s\033[0m' %
              (llxStack[-1]['logName'], llxStack[-1]['llxLineNum'], string))
    else:
        print('\033[1;30mDEVEL:   %s\033[0m' % string)
    if arguments:
        print('\033[1;30m'),
        for arg in arguments:
            pprint.pprint(arg)
        print('\033[0m')


def createHeading(level, content):
    """Create headings.

    This creates headings of levels H0 to H5. These levels are mapped
    to simple, section, subsection, subsubsection, paragraph and subparagraph
    H0 and 'simple' are special: no numbering, not toc entry, useful for step
    by step descriptions.
    Parameters:
    level (int)      - the level from 0 to 5
    content (string) - the string containing title and optional label
    content gets split into headingtext#label
    """
    # TODO - recheck the labeling, especially because H0 seems to fail...
    global isHidden
    hInfo = content.rsplit('#', 1)
    hInfo[0] = re.sub(r'([_&%$#])', esc, hInfo[0])
    debug('Creating Heading section at level %d' % level)
    if (level - currentHeading) > 1:
        if currentHeading == 0:
            error('First Heading in document must be H1')
            sys.exit(1)
        warn('Heading level jump from %d to %d' % (currentHeading, level))
    if level == 1:
        # \newpage + \section{Text} ( + \label{sec:label} )
        headText = '\\newpage\n\\section{%s@}' % hInfo[0]
    elif level == 2:
        # \subsection{Text} ( + \label{sec:label} )
        headText = '\\subsection{%s@}' % hInfo[0]
    elif level == 3:
        # \subsubsection{Text} ( + \label{sec:label} )
        headText = '\\subsubsection@{%s@}' % hInfo[0]
    elif level == 4:
        # \paragraph{}\mbox{}\\ (mbox to have new line after title)
        headText = '\\paragraph{%s@}\mbox{}\\\\' % hInfo[0]
    elif level == 5:
        # \subparagraph
        headText = '\\subparagraph{%s@}\mbox{}\\\\' % hInfo[0]
    elif level == 0:
        # Unnumbered - special defined simple
        #headText = '\\subparagraph*{%s@}\mbox{}\\\\' % hInfo[0]
        headText = '\\simple*{%s@}\mbox{}\n\n\\noindent\n' % hInfo[0]
    else:
        error('Bad level for heading: %d (only allowed H0 to H5)' % level)
        exit(1)
    if isHidden:
        docBody.append('\\color{texthidden}')
    if len(hInfo) > 1:
        debug('Heading has label: "%s"' % hInfo[1])
        if hInfo[1] in labels:
            docBody.append(re.sub('@',
                                  '\colorbox{yellow}{<dup label "%s">}' %
                                  hInfo[1], headText))
            error('Label "%s" is already in use in %s.llx, line %d' %
                  (hInfo[1],
                   labels[hInfo[1]]['file'],
                   labels[hInfo[1]]['line']))
        else:
            docBody.append(re.sub('@', '', headText))
            labels[hInfo[1]]['code2'] = '\emph{Chapter \\ref{sec:%s}}' % hInfo[1]
            labels[hInfo[1]]['text'] = hInfo[0]
            labels[hInfo[1]]['line'] = llxStack[-1]['llxLineNum']
            labels[hInfo[1]]['file'] = llxStack[-1]['llxBase']
            docBody.append('\\label{sec:%s}' % hInfo[1])
    else:
        docBody.append(re.sub('@', '', headText))
    if isHidden:
        docBody.append('\\color{black}')
    if level == 0:
        return currentHeading
    else:
        return level


def createList(type, listContent):
    """Create lists.
    """
    keyword = {'1': 'itemize', 'n': 'enumerate'}
    if type == '1' or type == 'n':
        #docBody.append('\\begin{itemize}')
        #docBody.append('\\begin{enumerate}')
        docBody.append('\\begin{%s}' % keyword[type])
        if isHidden:
            docBody.append('\\color{texthidden}\n')
        for element in listContent:
            element = processSingleCharBlocks(element)
            docBody.append('  \\item %s' % element)
        if isHidden:
            docBody.append('\\color{black}\n')
        #docBody.append('\\end{itemize}')
        #docBody.append('\\end{enumerate}')
        docBody.append('\\end{%s}' % keyword[type])
    else:
        todo('implement other list types')
        exit(0)


def makeWarningBox(docBody, text):
    """Add a warning box into the document.

    For example, used if image files are not found. Only used
    internally, no user macro exists for this.
    """
    # \bfseries - not used, use textbf instead
    txt = re.sub(r'([_&%$#])', esc, text)
    docBody.append('\n\color{red}\n'
                   '\Large\sffamily\n'
                   '\colorbox{yellow}{\\textbf{%s}}\\\\\n'
                   '\color{black}\n'
                   '%s%s' %
                   (txt, ffamily[defFont], fsize[defFontSize]))
    return


def makePrivateBox(docBody, text):
    """Add a privatebox into the document.
    """
    # TODO: include into single makeBox() function with warningbox above
    # \bfseries - not used, use textbf instead
    docBody.append('\color{red}\n'
                   '\small\sffamily\n'
                   '\colorbox{black}{\\textbf{%s}}\\\\\n'
                   '\color{white}\n'
                   '%s%s' %
                   (text, ffamily[defFont], fsize[defFontSize]))
    return


def makeSampleTable(caption, label, numrows):
    """Create table contents for --makedoc example table

    Used to create large tables w/o blowing up the source file size.
    And it it is used as table to test all colors and display them.
    """
    tabsrc = []
    tabsrc.append('%%%%TAB %s#%s\nColorname;Type;Example' % (caption, label))
    for color in stdColors:
        text = 'EXAMPLE TEXT for LaLaTeX Coloring in "%s" AS DEMO' % color
        tabsrc.append('%s;Standard;%s' %
                      (color, '\\color{%s}{%s}' % (color, text)))
    for color in dviPsColors:
        text = 'EXAMPLE TEXT for LaLaTeX Coloring in "%s" AS DEMO' % color
        tabsrc.append('%s;DviPs;%s' %
                      (color, '\\color{%s}{%s}' % (color, text)))
    tabsrc.append('%%TAB\n')
    return '\n'.join(tabsrc)


def my_repl(m):
    """For replacement in Table Highlighting

    Table auto highlighting should only match on full words, but also
    reflect, if a word is followed by comma, or is within brackets.
    """
    keyword = m.group(2)
    key = re.sub(r'\\', '', keyword)
    colorname = tabHLight[key]
    suffix = ''
    prefix = ''
    # make sure to return escaped versions
    if m.group(3) in ('/', '.', ',', ':', ';', ')', '"', ']', '\''):
        suffix = m.group(3)
    if m.group(1) in ('/', '(', '[', '"', '\''):
        prefix = m.group(1)
    if prefix and suffix:
        return('%s\\color{%s}{%s}\\color{black}%s' %
               (prefix, colorname, keyword, suffix))
    elif prefix:
        return('%s\\color{%s}{%s }\\color{black} ' %
               (prefix, colorname, keyword))
    elif suffix:
        return(' \\color{%s}{%s}\\color{black}%s' %
               (colorname, keyword, suffix))
    else:
        return(' \\color{%s}{%s }\\color{black} ' %
               (colorname, keyword))


def makeTableRow(docBody, line, tablerow, tabinfos):
    """Add row to table.

    We support multiline rows, so a cell can have more than 1 line
    """
    global tablecol
    global isHidden
    global tabLineSep
    global tabFileContents
    # TODO: table header line should also be able to have >1 line
    colors = ['todd', 'teven']
    csvSep = tabinfos['tabdata']['csvsep']
    coldata = line.split(csvSep)
    tabflags = tabinfos['tabdata']['flags']
    headcolor = 'thead'
    if isHidden:
        headcolor = 'theadhidden'
    if coldata[0] == '\\textbf{Missing table contents}':
        headcolor = 'theadbad'
    if tablerow == 1:


        rowdata = []
        numlines = 0


        # label starting with @ indicates duplicate
        if '@' in tabinfos['tabdata']['label']:
            capt = '%s\colorbox{yellow}{<dup label "%s"}' % \
                   (tabinfos['tabdata']['caption'],
                    tabinfos['tabdata']['label'][1:])
            lab = '\\\\\n'
        else:
            capt = tabinfos['tabdata']['caption']
            lab = '\label{%s} \\\\\n' % tabinfos['tabdata']['label']
        ff = tabinfos['tabdata']['font']
        fs = tabinfos['tabdata']['fontsize']
        testing = os.path.abspath(llxStack[-1]['llxBase'])
        tf = testing
        # also handle spaces in path, this did break PIK documentation
        tf = re.sub(r'^(\.)*/', '', testing)
        tf = re.sub(r'/', '-', tf)
        tf = re.sub(r'\s', '_', tf)
        tf = re.sub(r'\.', '', tf)
        tabFileContents = '%s._%d' % (tf, tabinfos['tabdata']['count'])
        debug('Setting filecontents tmp name to "%s"' % tabFileContents)
        numcols = len(coldata)
        tablecol = numcols
        debug('Table has %d columns' % numcols)


        # new for multiple lines within heading...
        for cell in coldata:
            #print('have cell content "%s"' % cell)
            celldata = cell.split(tabLineSep)
            rowdata.append(celldata)
            if len(celldata) > numlines:
                numlines = len(celldata)
        #pprint.pprint(rowdata)
        linedata2 = ''
        for i in range(numlines):
            linelist = []
            for row in rowdata:
                if row:
                    # FIX: no # was allowed in table heads...
                    # TODO; need more fixing, this is just a first step.
                    # e.g. &, _ etc.. see line2print code below...
                    # how to handle csv separator??
                    lll = row.pop(0)
                    lll = re.sub('#', '\#', lll)
                    lll = re.sub('&', '\&', lll)
                    lll = re.sub('_', '\_', lll)
                    lll = re.sub('%', '\%', lll)
                    lll = re.sub('\$', '\\\$', lll)
                    linelist.append(lll)
                else:
                    linelist.append('')
            line2print = ' & '.join(linelist)
            linedata2 += '\n\\rowcolor{%s} \n%s' % (headcolor,line2print)
            linedata2 += '\\\\*\n'

        if '\\' in line:
            line = re.sub(r'\\ ', r'\\textbackslash{} ', line)
            line = re.sub(r'\\$', r'\\textbackslash{} ', line)
        line2print = re.sub('&', '\&', line)
        line2print = re.sub(csvSep, ' & ', line2print)
        line2print = re.sub('#', '\#', line2print)
        line2print = re.sub('_', '\_', line2print)
        line2print = re.sub('%', '\%', line2print)
        line2print = re.sub('\$', '\\\$', line2print)

        # prepare linedata with multiple lines 
        #linedata2 = ''
        #for cline in range(numlines):
        #    print('Processing line %d' % cline)
        #    linedata2 += '\n\\rowcolor{%s} \n%s' % (headcolor,rowdata[0][cline])
        #    linedata2 += '\\\\*\n'
        #print('New linedata: %s' % linedata2)
# \rowcolor{thead}
# Head1 & Head2 \\*
# \rowcolor{thead}
# Heada & Headb \\*

        # TODO: this breaks # within table heading


        linedata = '\\rowcolor{%s}\n%s \\\\\n' % \
                    (headcolor,line2print)

        verts = '|l' * (numcols-1) + '|X|'
        if 'A' in tabflags:
            # dropped the \rowcolors stuff again
            #docBody.append('\\rowcolors{1}{todd}{teven}\n')
            verts = re.sub('\|', '', verts)
        docBody.append('\\begin{filecontents*}{%s}\n'
                       '%s%s\n'
                       '\\begin{longtable}[c]{%s}\n'
                       '\caption[%s]{%s}\n'
                       '%s'
                       '\\hline\n'
                       #'\\rowcolor{%s}\n'
                       #'%s \\\\\n'
                       '%s'
                       '\\hline\n'
                       '\endfirsthead\n'
                       '\multicolumn{%d}{c}%%\n'
                       '{{\\tablename\ \\thetable{} -- '
                       'continued from previous page}} \\\\\n'
                       '\\hline\n'
                       #'\\rowcolor{%s}\n'
                       #'%s \\\\\n'
                       '%s'
                       '\\hline\n'
                       '\endhead\n'
                       '\multicolumn{%d}{c}{{\\tablename\ \\thetable{} -- '
                       'continued on next page}} \\\\\n'
                       '\endfoot\n'
                       '\endlastfoot\n' %
                       (tabFileContents, ff, fs, verts, capt, capt, lab,
                        #headcolor, line2print, numcols, headcolor, line2print,
                        #linedata, numcols, linedata,
                        linedata2, numcols, linedata2,
                        numcols))
    else:
        rowdata = []
        numlines = 0
        if len(coldata) != tablecol:
            # TODO collect all within table instead of line by line
            error('Bad # of tab columns: %d vs. %d defined by table header' %
                  (len(coldata), tablecol))
            sys.exit(1)
        for cell in coldata:
            celldata = []
            todo('More tests on ||| in tables and single char macros needed')
            # check for any x{nn|||mm} or x[nn|||mm} constructs and change to
            # x{nn}|||x{mm} instead. If no nn: skip it
            # Footnote macro is not checked - this would result in 2 footnotes
            cell = re.sub(r'((^|\s?)[ubimecp][\[{][\'\%\*\+\"\:\!\,\>\<\~\[\]'
                          '\@#\$\|\/\.\=\-\w\s\\&\(\)]*}?)',
                          mkT,
                          cell)
            for cell_line in cell.split(tabLineSep):
                # Any replacements handled based on cell lines
                # no evil char '#' escape must be done for named ref
                if not re.search(r'r{.*#.*}', cell_line):
                    cell_line = re.sub('#', '\#', cell_line)

                # Check for non-closed reference - just check, no modifications
                re.sub(r'((^|\s+)[r]{[#\\\/\.\=\-\w\s\\&\(\)]*}?)',
                       chkRef,
                       cell_line)
                cell_line = re.sub(r'((^|\s?)[ubimecpf][\[{][^}]*}?)',
                                   mkSC,
                                   cell_line)

                cell_line = re.sub('\$', '\\\$', cell_line)
                cell_line = re.sub('_', '\_', cell_line)
                cell_line = re.sub('\&', '\\\&', cell_line)
                cell_line = re.sub('%', '\%', cell_line)
                cell_line = re.sub(r'\\ ', r'\\textbackslash{} ', cell_line)
                cell_line = re.sub(r'\\$', r'\\textbackslash{} ', cell_line)
                cell_line = re.sub('\\\\'+pCurly['}'],
                                   '\\\\textbackslash{}'+pCurly['}'],
                                   cell_line)
                cell_line = re.sub('\\\\'+pCurly['{'],
                                   '\\\\textbackslash{}'+pCurly['{'],
                                   cell_line)

                # MACRO manual highlight via 0{} to 9{} macros
                # Hightlight should really focus on the single characters, the
                # auto highlight based on keywords should only match full words
                hilights = _THL_.findall(cell_line)
                for highlight in hilights:
                    hlmacro = highlight[1]
                    if int(hlmacro) in tabHLight.keys():
                        colorname = tabHLight[int(hlmacro)]
                    else:
                        warn('MACRO "$%s$" not defined for highlighting - '
                             'text will show in black...' %
                             hlmacro)
                        colorname = 'black'
                        # TODO - clean up to drop the number before the text
                    matchdata = re.sub(r'_', r'\\_', highlight[2])
                    matchdata = re.sub(r'&', r'\\&', matchdata)
                    matchdata = re.sub(r'\$', r'\\$', matchdata)
                    matchdata = re.sub(r'#', r'\\#', matchdata)
                    cell_line = re.sub(hlmacro + '\{' + matchdata + '\}',
                                       '\\color{%s}{%s }\\color{black}' %
                                       (colorname, highlight[2]),
                                       cell_line)

                # AUTO highlight based on content match
                if 'H' in tabflags:
                    devel('HIGH', tabHLight)
                    for keyword in tabHLight.keys():
                        # integers as key: these are the MACROs, skip here
                        if type(keyword) is int:
                            continue
                        colorname = tabHLight[keyword]
                        keyword = re.sub(r'_', r'\\\\\_', keyword)
                        keyword = re.sub(r'&', r'\\\\\&', keyword)
                        keyword = re.sub(r'\$', r'\\\\\$', keyword)
                        keyword = re.sub(r'#', r'\\\\\#', keyword)
                        keyword = re.sub(r'\?', r'\\\\\?', keyword)
                        # TODO: questionmark not matched, remains black
                        if re.search(r'{?' + keyword, cell_line):
                            rstr = ''.join(['(^|\/|\s|\(|\[|\"|\')(',
                                           keyword,
                                           ')($|\/|\s|\.|\,|\;|\:|\]|\"|\'|\))'])
                            cell_line = re.sub(rstr,
                                               my_repl,
                                               cell_line)

                celldata.append(cell_line)
            rowdata.append(celldata)
            if len(rowdata[-1]) > numlines:
                numlines = len(rowdata[-1])
        if numlines > 1:
            for i in range(numlines):
                linelist = []
                for row in rowdata:
                    if row:
                        linelist.append(row.pop(0))
                    else:
                        linelist.append('')
                line2print = ' & '.join(linelist)
                if 'A' in tabflags:
                    if isHidden:
                        docBody.append('\\rowcolor{%s}' %
                                       tabcolorshidden[tablerow % 2])
                    else:
                        docBody.append('\\rowcolor{%s}' %
                                       tabcolors[tablerow % 2])
                    docBody.append('%s \\\\' % line2print)
                else:
                    # important: \\* to have continuation lines on same page!!
                    # seems not work, if not using hlines, as done with
                    # alternatinv row colors, so for 'A' flag, do not use this
                    docBody.append('%s \\\\*' % line2print)
        else:
            # fix for r{ref#replacement} - create line2print from rowdata and
            # do no evil char removal here any more
            linelist = []
            for row in rowdata:
                if row:
                    linelist.append(row.pop(0))
                else:
                    linelist.append('')
            line2print = ' & '.join(linelist)
            if 'A' in tabflags:
                if isHidden:
                    docBody.append('\\rowcolor{%s}' %
                                   tabcolorshidden[tablerow % 2])
                else:
                    docBody.append('\\rowcolor{%s}' %
                                   tabcolors[tablerow % 2])
            docBody.append('%s \\\\' % line2print)
        if not 'A' in tabflags:
            docBody.append('\\hline\n')
    return


def makePdf(name):
    """Create a PDF output from generated tex file.
    """
    # need to handle return codes and do some timeout handling
    print 'Creating "%s.pdf" file from "%s.tex" ...' % (name, name)
    try:
        StdOut, StdErr = subprocess.Popen(['pdflatex', '-halt-on-error', name],
                                          stdout=subprocess.PIPE,
                                          stderr=subprocess.PIPE).communicate()
    except:
        error('LaTeX timed out creating pdf file - maybe use longer timeout '
              'or "pdflatex" command is missing?')
        return 1
    # TODO: check stdout/stderr - we might skip second run instead of stupidly
    #       run 3 times. Table row width adjustment also can require additional
    #       runs. It looks like 'pdflatex' writes all to stdout...
    haveErrors = None
    if StdOut:
        for line in StdOut.split('\n'):
            # TODO - check for more possible options
            if 'Error' in line or 'Fatal' in line:
                haveErrors = 1
                error('PDFLATEX ERROR >> %s' % line)
    if haveErrors:
        error('LaTeX failed to create pdf file - see above error(s)')
        return 1
    # Run a second iteration - Latex needs this for indexing
    out = subprocess.Popen(['pdflatex', '-halt-on-error', name],
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE).communicate()
    # Run a third time - this fixes the 'page 200 of 190' problem
    out = subprocess.Popen(['pdflatex', '-halt-on-error', name],
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE).communicate()
    print('Finished creating "%s.pdf"' % name)
    if not options.showpdf:
        # TODO: do not show this tip, if no viewer is installed
        print('TIP: use option --show to display the PDF automatically')
    return 0


def showPdf(pdffile, viewer):
    """ Show the PDF File after creation.

    Called if --show is specified as optional argument. In addition, a
    viewer can be selected by --viewer (default is evince)
    """
    # TODO: check returned subprocess data (stderr/stdout)
    if checkPkg(viewer) != 0:
        error('PDF viewer %s not installed - created PDF is not displayed' %
              viewer)
        return 1
    try:
        out = subprocess.Popen([viewer, pdffile],
                               stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE).communicate()
    except:
        error('Call to PDF viewer %s failed' % viewer)
        return 1
    return 0


def getScriptType(scriptfile):
    """Determine programming language for a given file."

    For simple scripts, check interpreter line. For other types of source code,
     different
    methods need to be used, like searching for special keywords.
    """
    # TODO - check python-magic to solve this. Different versions are
    # available, pip install differs from apt-get install python-magic..
    # No installed package most likely by default - so check for its presence
    todo('Handle script type detection using python magic as option')
    with open(scriptfile, 'r') as FH:
        for line in FH:
            Match = re.match(r'\s*#!\s*(/.*)\s*', line)
            # TODO: add more types and how to handle for example C code
            if Match:
                interpreter = Match.group(1)
                # TODO - this can be shortened !!
                debug('Found script: %s, matched: %s' %
                      (scriptfile, interpreter))
                if 'python' in interpreter:
                    debug("Python detected...")
                    return 'PYTHON'
                elif 'perl' in interpreter:
                    debug("Perl detected...")
                    return 'PERL'
                elif 'bash' in interpreter:
                    debug("bash detected...")
                    return 'BASH'
                elif 'ksh' in interpreter:
                    debug("ksh detected...")
                    return 'KSH'
                elif 'sh' in interpreter:
                    debug("sh detected...")
                    return 'SH'
                else:
                    error('Unknown interpreter...' + interpreter)
                    return 'UNKNOWN'
    return 'UNKNOWN'


def validateMacro(macro):
    """Check, if macro is allowed at that point in the source file.

    E.g. IMG statement must not be placed within a TODO block. The rules
    are defined in the forbidden dictionary.
    """
    global heading
    debug('Validating macro "%s", current Block is "%s"' %
          (macro, getCurrentBlock()))
    cB = getCurrentBlock()
    if not cB:
        return macro
    if macro in forbidden.keys():
        if cB in forbidden[macro]:
            error('Macro "%s" within "%s" section is not allowed. '
                  'You most likely forgot a closing "%s" statement' %
                  (macro, cB, cB))
            exit()
    else:
        debug('Macro "%s" - no negative indication found...' %
              macro)
    return macro


def getFullUserName():
    """Get the real name of current user.

    This works with Linux, will not do it with Windows...
    """
    username = pwd.getpwuid(os.getuid()).pw_gecos
    # the original login user, from which maybe a su - or sudo was done
    userorig = pwd.getpwuid(os.stat('/proc/self/fd/0').st_uid).pw_gecos
    # TODO: if these are not the same, a sudo or su - user had been done
    #       write a warning, if root is involved
    if username == 'root':
        username = ''
    return username


def createDirs(dirs, basedir=None):
    """Helper function to create directories

    A tuple of directories and an optional basedir, else using currentdir
    """
    for dirname in dirs:
        if basedir:
            dirname = basedir + '/' + dirname
        if os.path.exists(dirname):
            if os.path.isdir(dirname):
                info('Subirectory "%s" already exists, skipping ' % dirname)
            elif os.path.isfile(dirname):
                error('A file named %s already exists, cannot create '
                      'this directory...' % dirname)
            else:
                error('The object "%s" already exists, but is not a file '
                      'or directory...' % dirname)
        else:
            os.makedirs(dirname)
            info('Directory "%s" created.' % dirname)


def prepareCommonDir(llxcommon, filesToMove):
    """Prepare the lalatex common directory

    Called at each run of lalatex
    """
    homedir = expanduser('~')
    llxcommon = homedir + '/' + llxcommon
    currentdir = os.getcwd()
    debug('Preparation of common LaLaTeX directory: %s' % llxcommon)
    debug('Current directory is: %s' % currentdir)
    #if options.makedoc:
    #    info('Called with --makedoc option....')
    # 1. create this directory, if it does not yet exist
    todo('CREATE listings/images/tables subdir within "%s" as well' %
         llxcommon)
    if not os.path.exists(llxcommon):
        debug('Directory %s does not exist, will create it now' %
              llxcommon)
        os.makedirs(llxcommon)
    else:
        debug('Directory %s already exists, no create needed' %
              llxcommon)
    # TODO: check for success before proceeding with a copy
    # 2. Copy the passed files from current dir to this directory
    #    TODO: files2move: was coded as move operation, clean this up
    for file2move in filesToMove:
        src = '%s/%s' % (currentdir, file2move)
        dst = '%s/%s' % (llxcommon, file2move)
        if os.path.exists(src):
            debug('Try to copy %s to %s' %
                  (src, dst))
            if os.path.exists(dst):
                debug('DST %s already exists, skipping...' %
                      dst)
            else:
                debug('Running: shutil.copy2(%s,%s)' %
                      (src, dst))
                shutil.copy2(src, dst)
        else:
            debug('SRC %s does not exist, skipping' %
                  src)
            if not os.path.exists(dst):
                error('File %s needed in %s for correct setup, stopping...' %
                      (file2move, currentdir))
                sys.exit(1)
    # 3. Create standard default directories within commondir if not existing
    createDirs((srcDefaultDir, tabDefaultDir, imgDefaultDir),
               basedir=llxcommon)
    return llxcommon


def checkPkg(pkg):
    """Check, if a given package is installed.
    """
    debug('Check for package "%s"' % pkg)
    if rpm:
        txSet = rpm.TransactionSet()
        match = txSet.dbMatch('name', pkg)
        for package in match:
            if package['name'] == pkg:
                debug('Required package "%s" found installed by rpm package '
                      'manager' % pkg)
                return 0
    elif apt:
        cache = apt.Cache()
        #allInstalledPkgs = cache.keys()
        #if cache.has_key(pkg):
        if pkg in cache.keys():
            if cache[pkg].is_installed:
                debug('Required package "%s" found installed by apt package '
                      'manager' % pkg)
                return 0
            else:
                debug('Required package "%s" NOT found installed by apt '
                      'package manager' % pkg)
        else:
            error('Prereq package "%s" unknown to apt package manager' %
                  pkg)
            return 1
    else:
        error('Undefined package manager')
    return 1


def cleanup():
    """Cleanup temporary files.

    Clean up aux files and temporary table data created by filecontents.
    This can be avoided by using --keep flag, which might help debugging.
    """
    print('Cleaning up temporary data (use --keep to keep temporary files)')
    # IMPORTANT: 1. never,ever delete any llx files!!!
    #            2. Do not delete what you don't know!!!!
    currentDir = os.getcwd()
    info('Running cleanup of temporary files in "%s" for project "%s"' %
         (currentDir, currentLtxFileName))
    tabdel = [currentLtxFileName]
    for res in usedResources:
        if res.endswith('.llx'):
            tabdel.append(res.rsplit('/', 1)[1].replace('.llx', ''))
    files = [file for file in os.listdir(currentDir) if os.path.isfile(file)]
    for file in files:
        fullfilepath = currentDir + '/' + file
        # for the base latex stuff with versioned names
        if re.match(r'^' + currentLtxFileName +
                    r'-v\d{1,2}(\.\d){0,3}\.[htalo][sou].*', file):
            debug('Removing temp latex file "%s"' % fullfilepath)
            os.remove(file)
        # for table temporary data - this removes matched files named xxxx._n
        for filestem in tabdel:
            if re.match(r'.*-' + filestem + '\._\d+', file):
                debug('Removing temp table file "%s"' % fullfilepath)
                os.remove(file)
    # history has no version - may change this to fit regex above...
    if os.path.exists(currentLtxFileName + '.hst'):
        os.remove(currentLtxFileName + '.hst')
    return


def getCurrentBlock():
    """Get current block we are in.
    """
    if currentBlock:
        return currentBlock[-1]
    else:
        return None


def enterBlock(blk):
    """Enter a new block.
    """
    if blk != getCurrentBlock():
        currentBlock.append(blk)
        debug('Entered block "%s", depth is %d' %
              (blk, len(currentBlock)))
    return


def leaveBlock():
    """Leave the current block.
    """
    debug('Leaving block "%s", now back in "%s"' %
          (currentBlock.pop(), getCurrentBlock()))
    return


def esc(string):
    """Escape the given string.

    Meant to be called as repl function in re.sub
    """
    str = string.group(1)
    return '\\' + str


def mkT(string):
    """Handle tablinesep in tables within SC macros like b{}

    This is to avoid erroneuos unclosed curly bracket messages which
    happened in that case, and it allows now to display the text
    correctly split on 2 or more lines within a table cell.
    """
    str = string.group(1)
    if not tabLineSep in str:
        return str
    if re.match(r'^\s?[ubimecp]\[', str):
        if str.endswith('}'):
            newstr = str.replace('[', '{', 1)
            warn('BAD MACRO "%s" - autocorrected to "%s"' %
                 (str, newstr))
            str = newstr
        else:
            return str
    Match = re.match(r'^(\s?[ubimecp])\{(.*)\}', str)
    if not Match:
        return str
    macro = Match.group(1)
    return re.sub(macro + r'{}',
                  '',
                  macro +
                  '{' +
                  re.sub(r'\|\|\|',
                         '}'+tabLineSep+macro+'{',
                         Match.groups()[1]) + '}')


def mkSC(string):
    """Handle all single char macros except reference r{}.

    Meant to be called with re.sub functions within table
    processing and processSingleCharBlocks()
    """
    macrepl = {'b': '\\textbf',
               ' b': ' \\textbf',
               'i': '\\textit',
               ' i': ' \\textit',
               'u': '\\textul',
               ' u': ' \\textul',
               'p': '\\textsf',
               ' p': ' \\textsf',
               'm': '\\hl',
               ' m': ' \\hl'}
    str = string.group(1)
    result = ''
    # Added autodetect + correct for x[nnn} bad macro format
    # which otherwise would crash later on at pdflatex run
    # TODO: check within tables and all combinations
    #       not really finally done, cannot handle m[text]
    # which runs into unclosed curly bracket
    # TODO: with handleCurly() - this is obsolete at the moment
    if re.match(r'^\s?[ubimecpf]\[', str):
        if str.endswith('}'):
            newstr = str.replace('[', '{', 1)
            # we could throw an error and exit or warn and correct
            warn('BAD MACRO "%s" - autocorrected to "%s"' %
                 (str, newstr))
            str = newstr
        else:
            # now: macro with [ but no curly close
            return str
    macro = str.split('{', 1)[0]
    # detect of incomplete macros (unclosed curly bracket)
    # TODO: with handleCurly() - this is obsolete at the moment
    if not str.endswith('}'):
        error('Unclosed curly brackets, string is "%s"' %
              str)
        sys.exit(1)
    content = re.sub(r'^\s?[ubimecpf]{', '', str)
    # >> and << in marked produce strange pdf results, because
    # the produced code \hl{>>} from soul package does not move
    # forward, so that following text overlaps with the > sign.
    # so avoid latex >> to special > production
    # same with underline, so do it here as well
    # Just a hack, there might be better solutions

    if macro in ('m', ' m', 'u', ' u'):
        # TODO: the below re.match matches also for non umlauts...
        # seems that I need to readd unicode conversion again...
        if re.match('[äoüÄÖÜ]', content.encode('utf-8'), re.UNICODE):
            error('Umlaut not allowed in macros "m" and "u", offending '
                  'string: %s)' % str)
            sys.exit(1)
        content = content.replace('>>', '>{}>{}')
        content = content.replace('<<', '<{}<{}')
    content = re.sub(r'}$', '', content)
    if macro in ('u', ' u', 'b', ' b', 'i', ' i', 'e', ' e', 'm', ' m'):
        content = content.replace('\\', r'\textbackslash ')
        content = content.replace('~', r'\textasciitilde ')
    # path names require some extra processing
    if 'p' in macro:
        content = content.replace('\\', r'\textbackslash\allowbreak ')
        # FIX - do not allow break on first '/' at start of content
        # because it is ugly in resulting text
        if content.startswith('/'):
            content = r'/\allowbreak '.join(content.rsplit('/', 1))
        else:
            content = content.replace('/', r'/\allowbreak ')
        content = content.replace('_', r'_\allowbreak ')
        #content = content.replace('~', r'\textasciitilde ')
        content = '\\small{' + content.replace('~', r'\textasciitilde ') + '}'
    if macro in macrepl.keys():
        result = '%s{%s}' % (macrepl[macro], content)
    elif 'e' in macro:
        #result = (' \\textbf{\\textit{%s }}' %
        result = (' \\textbf{\\textit{%s}}' %
                  content)
    elif 'c' in macro:
        content = content.replace(pCurly['{'], r'\textbraceleft')
        content = content.replace(pCurly['}'], r'\textbraceright')
        content = content.replace('--', '-{}-')
        #content = content.replace('~', r'\textasciitilde{}')
        # the following change did break 'curlamp' .... 20.02.2016 - fix
        #content = '\\small{' + content.replace('~', r'\textasciitilde ') + '}'
        # 20.02.2016 - fix missing space - ok now
        # TODO: Fix size if within table: small for normal text, else get
        # current table font size, same needed for path above
        content = '\\small{' + content.replace('~', r'\textasciitilde ') + ' }'
        if isHidden:
            result = (' \color{hcmdcolor}'
                      '\\textbf{\\texttt{%s }}'
                      '\color{texthidden}' %
                      content)
        else:
            result = (' \color{cmdcolor}'
                      '\\textbf{\\texttt{%s }}'
                      '\color{black}' %
                      content)
    elif 'f' in macro:
        result = (' \\footnote{%s}' %
                  content)
    else:
        error('mkSC: bad macro "%s" (should never arrive here)' %
              macro)
        sys.exit(1)
    return result


def chkRef(string):
    """Check a r{x#y z} reference string for closed brackets.

    Meant to be called with re.sub function during standard compile
    process. This allows to print messages along with the current
    line number, which is not possible during mkRef(), which runs
    during the postprocessing phase.
    """
    str = string.group(1)
    if not str.endswith('}'):
        error('Unclosed curly brackets in reference, string is "%s"' %
              str)
        sys.exit(1)
    return ''


def mkRef(string):
    """Handle a r{x#y z} reference string.

    Meant to be called with re.sub functions
    """
    global labels
    str = string.group(1)
    ref = ''
    str = re.sub(r'\\#', '#', str)

    # detection of incomplete ref macros (unclosed curly bracket)
    if not str.endswith('}'):
        error('Unclosed curly brackets in reference, string is "%s"' %
              str)
        sys.exit(1)

    # ref with hash (and possible replacement text)
    if '#' in str:
        [Label, Replace] = str.split('#', 1)
        rawLabel = re.sub(r'(^\s*r{)', '', Label)
        Label = re.sub(r'(^\s*r{)', '', Label)
        Replace = re.sub(r'}$', '', Replace)
        if not Replace:
            # take care of implicit defs with hfcmdict!!!
            if Label in labels.keys() and 'text' in labels[Label].keys():
                Replace = labels[Label]['text']
            else:
                warn('No default replacement text for label "%s"' % Label)
                Replace = 'Missing default label text'
        # we COULD handle bad characters here in an else statement
        # e.g. badcode = re.findall(r'([_&()])',Replace)

    else:
        Replace = ''
        # Take care of previously escaped characters in Label name!!
        rawLabel = re.sub(r'(^\s*r{|})', '', str)
        Label = re.sub(r'(^\s*r|{|}|\\)', '', str)

    if Label in labels:
        # TODO - cleanup labels structure - code2/code key
        if Replace:
            labeldata = re.match(r'.*ref{([^}]*)}.*',
                                 labels[Label]['code2']).groups()[0]
            ref = ' \emph{\hyperref['+labeldata+']{'+Replace+'}}'
        else:
            if Label in labels.keys() and 'code2' in labels[Label].keys():
                ref = ' ' + labels[Label]['code2']
            else:
                error('Label "%s" - missing code2 in labels structure' %
                      Label)
                sys.exit(1)
    # label does not exist - create warning
    else:
        warn('Referenced label "%s" does not exist, raw: "%s"' %
             (Label, rawLabel))
        ref = ' \\hl{<MISSING LABEL: ' + rawLabel + '>}'
    if not ref:
        error('UNKNOWN FATAL ERROR in reference processing...')
        sys.exit(1)
    return ref


def verbRepl(string):
    """TEST ONLY

    not yet elegant, but works...
    """
    str = string.group(1)
    str = str.replace('\\b', '<llxvesc>\color{blue}\\verb<llxvesc>', 1)
    str = str.replace('\\r', '<llxvesc>\color{red}\\verb<llxvesc>', 1)
    str = str.replace('\\g', '<llxvesc>\color{darkgreen}\\verb<llxvesc>', 1)
    str = str.replace('\\o', '<llxvesc>\color{orange}\\verb<llxvesc>', 1)
    if isHidden:
        str = str.replace('++', '<llxvesc>\color{texthidden}\\verb<llxvesc>', 1)
    else:
        str = str.replace('++', '<llxvesc>\color{black}\\verb<llxvesc>', 1)
    return str


def makeVerbatim(string):
    """make given string suitable for verbatim with \verb

    The function dynamically selects an escape character from
    a given set of possible escapes in vescape
    Counter verbatimline (global) is handled in this function
    """
    # TODO: \verb|txt |\color{red}\verb|txt|\color{black}\verb| txt...|
    #       \verb|txt                   txt                     txt...|
    #       colored highlights within verbatim are possible this way
    #       how to mark text in original, and which color to use ??
    # we could use ++string++ as indicator
    # Do this along with the line length handling
    global verbatimline
    global verbatimcount
    global workVerbatim
    # UUID shortener - useful for many outputs by removing middle characters
    # 9f8c8ab7-521d-4612-8354-2f13081f13c4
    # same for WWPNs in FibreChannel - anything worth to shorten
    # could be handled here
    # lladdr = ''.join((lladdr.rsplit(':',16)[0],'...',
    #                  lladdr.split(':',15)[15]))
    # new line except for first line in verb section
    limit = verbPort
    if 'LAND' in currentBlock:
        limit = verbLand
    s = ''
    if re.match(r'\s*\S+', string):
        verbatimcount += 1
    if verbatimline:
        s = '\\\\'
    verbatimline += 1
    for escp in vescape:
        if not escp in string:
            if escp != vescape[0]:
                debug('Using alternative escape "%s" for "%s"' %
                      (escp, string))
            break
        else:
            if esc == vescape[-1]:
                error('No verbatim escape found for "%s"' %
                      string)
                # TODO this return is not ok, make a bad verbatim in red
                #      as with empty verb
                return ('%s\\colorbox{red}'
                        '{ERROR FOR VERBATIM LINE - NO ESCAPE SEQUENCE LEFT}' %
                        s)

    maxlen = limit[int(vFontSize)] - 1
    # check for colored items
    hldata = []
    for h in re.finditer(r'(\\[rbgo]{1}[^++]+\+\+)', string):
        hldata.append(h)
    if isHidden:
        cont = ('%s\color{orange}\\verb%s>%s\color{texthidden}\\verb%s' %
                 (escp, escp, escp, escp))
    else:
        cont = ('%s\color{orange}\\verb%s>%s\color{black}\\verb%s' %
                 (escp, escp, escp, escp))

    #debug('Verbatim: "%s"' % string)
    if hldata and len(string) >= limit[int(vFontSize)] + 4 * len(hldata):
        hlpoints = []
        hlstrings = []
        for data in hldata:
            hlpoints.append(data.start())
            hlpoints.append(data.end() - 2)
            hlstrings.append(data.groups()[0][:2])
        startidx = 0
        idx = 0
        countn = 0
        inside = 0
        sublist = []
        suffix = ''
        prefix = ''
        prefixes = ['', ]
        currenthl = 0
        lc = 0
        while idx < len(string):
            if countn < maxlen:
                if len(hlpoints) > 0 and idx == hlpoints[0]:
                    inside = 1 - inside
                    if inside:
                        prefix = hlstrings[currenthl]
                        currenthl += 1
                        idx += 2
                        suffix = '++'
                    else:
                        prefix = ''
                        suffix = ''
                        idx += 2
                    del hlpoints[0]
                countn += 1
            else:
                prefixes.append(prefix)
                sublist.append(prefixes[lc] + string[startidx:idx] + suffix)
                startidx = idx
                if hlpoints and startidx == hlpoints[0]:
                    if not re.match(r'^\\[rbgo].*',string[startidx:]):
                        startidx += 2
                    prefix = ''
                    prefixes[-1] = ''
                countn = 1
                lc += 1
            idx += 1

        sublist.append(prefixes[lc] + string[startidx:idx])

        idx = 1
        for st in sublist:
            st = re.sub(r'(\\[rbgo]{1}[^++]+\+\+)', verbRepl, st)
            st = re.sub('<llxvesc>', escp, st)
            if idx < len(sublist):
                workVerbatim.append('%s\\verb%s%s%s%s' %
                                    (s, escp, st, cont, escp))
                verbatimcount += 1
            else:
                workVerbatim.append('\\verb%s%s%s' % (escp, st, escp))
                verbatimline += 1
            idx += 1
        return 0

    elif not hldata:
        # no colored stuff within this line
        if len(string) > limit[int(vFontSize)]:
            idx = 1
            sublist = [string[i:i+maxlen] for i in range(0,
                                                         len(string),
                                                         maxlen)]
            for st in sublist:
                if idx < len(sublist):
                    workVerbatim.append('%s\\verb%s%s%s%s' %
                                        (s, escp, st, cont, escp))
                    verbatimcount += 1
                else:
                    workVerbatim.append('\\verb%s%s%s' % (escp, st, escp))
                    verbatimline += 1
                idx += 1
            return 0

    string = re.sub(r'(\\[rbgo]{1}[^++]+\+\+)', verbRepl, string)
    string = re.sub('<llxvesc>', escp, string)
    #debug('Verbatim: "%s"' % string)
    workVerbatim.append('%s\\verb%s%s%s' % (s, escp, string, escp))
    return 0


def processSingleCharBlocks(line):
    """Process single charachter x{} blocks

    Currently gets called from within 'list' and 'normal line' processing.
    This also includes TODOs etc, because lines in between macros are
    processed like normal lines in most cases.
    It is NOT used for table processing at this time.
    """
    # TODO: Think about nesting, e.g. italic in marked or bold+italic etc...
    # Check for non-closed reference - just check, no modifications
    re.sub(r'((^|\s+)[r]{[#\\\/\.\=\-\w\s\\&\(\)]*}?)',
           chkRef,
           line)
    # TODO replace other backslashes in normal text with no space immedieately
    # following. Note: these areseen as \keywords by latex, and cause errors
    # TODO: real keywords will not be escaped, because we match for ' \word '
    # note the spaces before AND AFTER, so using \textit{mytext} will work
    Matches = re.findall(r'\s+\\{1}(\w+)\s+', line)
    for Match in Matches:
        if not Match in ['LaTeX', 'copyright']:
            line = re.sub('\\\\' + Match, '\\\\textbackslash ' + Match, line)
    # Processing line
    line = re.sub(r'((^|\s?)[ubimecpf][\[{][^}]*}?)',
                  mkSC,
                  line)
    line = re.sub('~', '\\\\textasciitilde{}', line)
    line = re.sub('&', '\&', line)
    line = re.sub('%', '\%', line)
    line = re.sub('\$', '\\\$', line)
    line = re.sub('\\\\ ', '\\\\textbackslash{} ', line)
    line = re.sub('\\\\$', '\\\\textbackslash{} ', line)
    line = re.sub('\\\\' + pCurly['}'],
                  '\\\\textbackslash{}' + pCurly['}'],
                  line)
    line = re.sub('\\\\' + pCurly['{'],
                  '\\\\textbackslash{}' + pCurly['{'],
                  line)
    line = re.sub('#', '\#', line)
    line = re.sub('_', '\_', line)
    return line


def rewriteLtx():
    """Rewrite LTX file if updated HST information availalble.

    This mechanism might also be used for other changes to the
    original source.
    """
    global haveHistory
    global _HST_
    debug('Writing Document History Updates into "%s"' % currentLtxFileName)
    debug('Username is "%s"' % userName)
    hstauthor = author
    if userName:
        hstauthor = userName
    TGT = open(currentLtxFileName + '.new', 'w+')
    count = 0
    with open(currentLtxFileName + '.llx', 'r') as SRC:
        for line in SRC:
            if count < 2:
                Match = re.match(r'^%%HST', line)
                if Match:
                    if count == 1:
                        TGT.write('%s#%s#%s#%s\n' %
                                  (docVersion,
                                   docdate.split(',')[1],
                                   hstauthor,
                                   hstNewComment))
                        debug('adding now: %s#%s#%s#%s' %
                              (docVersion,
                               docdate.split(',')[1],
                               hstauthor,
                               hstNewComment))
                    count += 1
            TGT.write('%s' % line)
    TGT.close()
    #shutil.copy2(currentLtxFileName + '.llx',currentLtxFileName + '.bak')
    shutil.move(currentLtxFileName + '.new', currentLtxFileName + '.llx')


def getPathList(filename, defPath):
    """ Create list of paths to search for a type of include.

    We distinguish: no defPath, images, listings, tables
    This output is used with findFile() to provide additional default
    search paths for a given file.
    """
    # TODO: if we are in an included LTX file, the path of this should
    #       be used as the current directory starting point, so that
    #       images etc. are found
    todo('getPathList() - handle case of included LTX')
    info('Searching INCLUDE file "%s"' % filename)
    searchpaths = []
    if len(llxStack) > 2:
        devel('"%%%%INC %s" called within "%s"...' %
              (filename, llxStack[-1]['llx']))
        devel('"%s" itself was included from "%s" using "%%%%INC %s"' %
              (llxStack[-1]['llx'],
               llxStack[-2]['llx'],
               llxStack[-1]['llxBase']))
        # get basepath as the path, in which the included llx file is located
        basepath, basefile = llxStack[-1]['llx'].rsplit('/', 1)
        basepath = basepath + '/'
    else:
        basepath = ''
        devel('We are not within an included llx...')
    devel('Basepath for further search: "%s"' % basepath)
    # We just add this basepath to all search path infos, except commondir
    if not os.path.isabs(filename):
        reldirname = os.path.dirname(filename)
        if reldirname:
            debug('RELATIVE PATH "%s"' % reldirname)
            if filename.startswith('..'):
                # We handle this like abs path: look only here and defpath
                # but also visit any defPath subdir below.
                # No check in lalatex common dir!!
                debug('reldirname "%s"' % reldirname)
                if defPath:
                    searchpaths = [basepath + reldirname + '/' + defPath]
            else:
                if defPath:
                    searchpaths = [basepath + reldirname + '/' + defPath,
                                   commondir + '/' + reldirname,
                                   commondir + '/' + reldirname + '/' +
                                   defPath]
                else:
                    searchpaths = [commondir + '/' + reldirname]
        else:
            debug('NO PATH specified with "%s"' % filename)
            # empty path '' in searchpaths will be skipped in findFile anyway
            searchpaths = [basepath + defPath,
                           commondir]
            if defPath:
                searchpaths.append(commondir + '/' + defPath)
    return searchpaths


def findFile(fname, pathlist):
    """Find a given filename in a list of possible directories
    """
    # first just check the given name (in current directory)
    if not os.path.isabs(fname) and len(llxStack) > 2:
        basepath, basefile = llxStack[-1]['llx'].rsplit('/', 1)
        filename = basepath + '/' + fname
    else:
        filename = fname
    if os.path.exists(filename):
        info('File "%s" found' % filename)
        return filename
    if not pathlist:
        return ''
    info('File "%s" not found, searching given alternative paths' % filename)
    base = os.path.basename(filename)
    for path in pathlist:
        if path == '':
            continue
        full = path + '/' + base
        debug('Checking for "%s"' % full)
        if not os.path.exists(full):
            debug('File "%s" not found' % full)
        else:
            info('File "%s" found' % full)
            return full
    # getting here - nothing found at all
    return ''


def makeVar(varname):
    """Provide variable replacement
    """
    var = varname.group(2)
    if var in vardict.keys():
        debug('Variable "%s" resolved as "%s"' %
              (var, vardict[var]))
        return vardict[var]
    else:
        return varname.group(0)


def addResource(resname, includer, type):
    """Add an included file as key

    This is a base for generating reports and for the future tarball
    export function.
    """
    # TODO - the complete structure needs to be designed - this is
    #        just a quick starting point
    if 'includer' in usedResources[resname].keys():
        usedResources[resname]['includer'].append(includer)
    else:
        # TODO - handle same includer multiple times
        usedResources[resname]['includer'] = [includer]
        usedResources[resname]['type'] = type
    return


def handleCurly(line):
    """Addon to handle curly brackets

    I'm still not satisfied with this, but curly brackets should be
    handled in some way that avoids the need to escape them.
    This code could even handle much more than just preproecessing
    the line with replacements.
    """
    # TODO: This breaks the auto correction method for m[ddd} bad
    #       opening bracket typo...
    # but we could put in more handling into this function anyway
    # TODO: check, if replacing pCurly logic by \textbraceleft/right
    #       - this could make things easier and even avoid the later
    #         postprocessing step
    newline = ''
    wk = ''
    idx = 0
    pendingSC = 0
    ccc = line[0]
    if ccc in pCurly.keys():
        newline = pCurly[ccc]
    else:
        newline = ccc
    for idx in range(1, len(line)):
        ccc = line[idx]

        if ccc == '{':
            if line[idx-1] in 'ubimecpfr0123456789':
                if wk:
                    if pendingSC:
                        if pCurly['}'] in wk:
                            wk = '}'.join(wk.rsplit(pCurly['}'], 1))
                            newline += wk + '{'
                            wk = ''
                        else:
                            wk = '}'.join(wk.rsplit(pCurly['}'], 1))
                            wk += pCurly['{']
                    else:
                        if wk.count(pCurly['}']) > 1:
                            wk = '}'.join(wk.rsplit(pCurly['}'], 1))
                        newline += wk + '{'
                        wk = ''
                        pendingSC = 1
                else:
                    if pendingSC:
                        wk += pCurly['{']
                    else:
                        newline += wk + '{'
                        wk = ''
                        pendingSC = 1
            else:
                wk += pCurly['{']

        elif ccc == '}':
            wk += pCurly['}']

        else:
            wk += ccc

        idx += 1

    if pendingSC:
        if pCurly['}'] in wk:
            wk = '}'.join(wk.rsplit(pCurly['}'], 1))
        else:
            error('UNCLOSED BRACKETS: "%s"' % line)
            sys.exit(1)
    newline += wk
    return newline


def chkEscape(line):
    """Check for escaped characters in given line

    Needed for all llx lines and those returned by RUN
    """
    # Escaped \# or \& does break pdflatex run
    # TODO: rethink and make it extra function, is needed within
    # RUN macro returned lines as well
    if re.search(r'\\#', line):
        warn('Do not use escaped "\#" - fixing this for you now...')
        line = re.sub(r'\\#', '#', line)
    if re.search(r'\\&', line):
        warn('Do not use escaped "\&" - fixing this for you now...')
        line = re.sub(r'\\&', '&', line)
    # Escaped \% does cause follow on text to be dropped
    if re.search(r'\\%', line):
        warn('Do not use escaped "\%" - fixing this for you now...')
        line = re.sub(r'\\%', '%', line)
    return line


def addTableWorkContents(content, tableData):
    """ Add table row content to list/dict
    """
    global workTableList
    global tabSortBy
    global tabColSort

    # TODO: error with "col1","col2","col,3","col4"...
    # see example from VW VIO data
    # specialseparator: ","
    # we assume: if first char is " and last char is ": we have this format
    # TODO: consider the use of python csv package again...
    # in combination with a temp file for table contents

    if content.startswith('"') and content.endswith('"'):
        if not '"' in tableData['csvsep']:
            tableData['csvsep'] = '"' + tableData['csvsep'] + '"'
            debug('Adjusting csv separator to <%s>' % tableData['csvsep'])
        content = re.sub(r'^"', '', content)
        content = re.sub(r'"$', '', content)
    numcol = content.count(tableData['csvsep']) + 1
    elements = content.split(tableData['csvsep'])

    # not as good, because "ab";"ab;x";"c" does not work
    # only "ab","ab,x","c" works with comma (and : also ok)
    # and special """asdf""","asdf",... from klaus example fails.
    #for elements in csv.reader([content], delimiter = ';'):
    #dialect = csv.Sniffer().sniff(content, delimiters = [","])
    #dialect = csv.Sniffer().sniff(str(content), delimiters = [",", ";", ":"])

#    #dialect = csv.Sniffer().sniff(content.encode('utf-8'))
#    dialect = csv.Sniffer().sniff(str(content))
#    #dialect = csv.Sniffer().sniff(str(content.decode('utf-8')))
#    print('Delimiter: %s' % dialect.delimiter)
#    for elements in csv.reader([content], dialect):
#        pprint.pprint(elements)
#        numcol = len(elements)

    if not workTableList:
        info('Table Head info "%s" - "%s" - %d columns' %
             (tableData['caption'],
              content,
              numcol))
        tableData['numcols'] = numcol
        devel('elements', elements)
        tableData['cols_filtered'] = 0
        if tabColSort:
            # get the data
            # TODO: colname sorting
            tableData['col_order'] = [int(i)-1 for i in tabColSort.split(',')]
            if len(tableData['col_order']) < numcol:
                info('Detected filtered columns...')
                tableData['cols_filtered'] = numcol - len(tableData['col_order'])
                tableData['numcols'] = numcol - tableData['cols_filtered']
                debug('Basedata: %d cols, filtered: %d, remaining %d' %
                      (numcol,
                       tableData['cols_filtered'],
                       tableData['numcols']))
            elements = [elements[i] for i in tableData['col_order']]
        if tabSortBy:
            # this works on the COL-ORDERED! data
            if tabSortBy.isdigit():
                if (int(tabSortBy) > numcol - tableData['cols_filtered'] or
                        tabSortBy == '0'):
                    error('Bad sort column number %s (1 - %d allowed) - '
                          'continuing unsorted...' %
                          (tabSortBy, tableData['numcols']))
                    tabSortBy = ''
                else:
                    tableData['sortkey'] = elements[int(tabSortBy)-1]
                    tableData['sortidx'] = int(tabSortBy)-1
            else:
                if tabSortBy in elements:
                    tableData['sortkey'] = tabSortBy
                    tableData['sortidx'] = elements.index(tabSortBy)
                else:
                    error('Bad sort column name "%s" - continuing unsorted' %
                          tabSortBy)
                    tabSortBy = ''
    else:
        if numcol - tableData['cols_filtered'] != tableData['numcols']:
            error('Bad column number %d vs. %d - skipping' %
                  (numcol, tableData['numcols']))
            # for now: skip the line, we might add a marked line to the output
            return 0
    if tabColSort and workTableList:
        elements = [elements[i] for i in tableData['col_order']]
    workTableList.append(elements)
    return 1


def exportProjectTarball():
    """Create a tarball containing all required files for building the PDF

    Rule: Only include active stuff, no unused resources
    """
    # Would be nice to have export run without compiling a new pdf...
    last_path_element = os.path.basename(os.path.normpath(os.getcwd()))
    tarball = 'lalatex-export-' + last_path_element + '-' + tStamp
    info('STILL TESTING: create tarball %s' % tarball)
    # here we add the default directories into the export
    for defaultDir in (srcDefaultDir,
                       tabDefaultDir,
                       imgDefaultDir,
                       wrkDefaultDir):
        if os.path.exists(defaultDir):
            usedResources[os.path.abspath(defaultDir)]['type'] = 'dir'
        else:
            warn('Subdirectory "%s" not found, skipping' %
                 defaultDir)
    devel('resources to process', usedResources)
    # Get resources to add into the tarball
    filesToAdd = {}
    debug('Lalatex common dir is "%s"' % llxsubdir)
    for file in (usedResources.keys() +
                 [os.path.abspath(currentLtxFileName + '.llx')]):
        if commondir in file:
            debug('Processing "%s" (%s)' % (file, commondir))
            filesToAdd[file] = (llxsubdir + '/' +
                                file.replace(commondir + '/', ''))
        # TODO: this is bad, see crash in DWD project: 
        # (Pdb) file
        # u'/home/herbert/Documents/DWD/SAN/lib-away.csv'
        # (Pdb) last_path_element
        # 'Docu' 
        # This gives a match, but is wrong !!!!
        #elif last_path_element in file:
        elif '/' + last_path_element + '/' in file:
            debug('Processing "%s"' % file)
            #if 'away' in file:
            #    pdb.set_trace()
            filesToAdd[file] = (last_path_element + '/' +
                                file.rsplit(last_path_element + '/', 1)[1])
        else:
            error('Not sure how to handle "%s" - skipping' % file)
            warn('Did you include an llx with ".." in path?')
    devel('Resulting list of files to add', filesToAdd)
    # do it ...
    # when adding the default dirs just to create them in the imported data
    with closing(tarfile.open(tarball, "w:gz")) as tar:
        for file in filesToAdd.keys():
            debug('Adding: "%s" as "%s"' % (file, filesToAdd[file]))
            tar.add(file, arcname=filesToAdd[file], recursive=False)
    # TODO - more checking
    return 0


def importProjectTarball(tarball):
    """Import a tarball into given directory

    Special handling for lalatex-common stuff, checking for collisions
    if filenames and contents
    """
    # TODO: might need to replace if unpacking updated project...
    print('Import for "%s" called' % tarball)
    debug('Common lalatex directory: "%s" (%s)' % (commondir, llxsubdir))
    currentdir = os.getcwd()
    debug('Current directory is: %s' % currentdir)
    with closing(tarfile.open(tarball, "r")) as tar:
        # prepare member lists for extractall()
        commonmembers = []
        standardmembers = []
        members = tar.getmembers()
        names = tar.getnames()
        devel('tarfile members', members)
        devel('tarfile membernames', names)
        # filter out lalatex-common members
        for member in members:
            if member.issym():
                warn('Found symlink "%s", skipping...' %
                     member.name)
                continue
            # handle files with lalatex common
            if llxsubdir in member.name:
                fullname = (commondir + '/' +
                            member.name.replace(llxsubdir + '/', ''))
                debug('llx-common: fullname "%s"' % fullname)
                if os.path.exists(fullname):
                    # check md5sums: if same, we can skip without any problems,
                    # if different: there's an issue here with colliding names
                    #warn('"%s" already exists, comparing md5 sums' % fullname)
                    tarhash = hashlib.md5(tar.extractfile(member).read()).hexdigest()
                    orghash = hashlib.md5(open(fullname, 'rb').read()).hexdigest()
                    if tarhash == orghash:
                        info('File "%s": identical copy already exists ...' %
                             fullname)
                        debug('TAR: Orig %s vs tar %s' % (orghash, tarhash))
                    else:
                        error('Same file "%s" with different contents - '
                              'problem here, skipping' %
                              fullname)
                        sys.exit(1)
                else:
                    debug('Found "%s" to be placed in "%s"' %
                          (member, commondir))
                    commonmembers.append(member)
            else:
                fullname = os.path.abspath(member.name)
                if os.path.exists(fullname):
                    info('"%s" already exists, will not add to list' %
                         fullname)
                else:
                    info('Found "%s" (%s)' % (member.name, fullname))
                    standardmembers.append(member)
        devel('commonmembers', commonmembers)
        if commonmembers:
            homedir = expanduser('~')
            info('Exctracting requisite "%s" contents to %s' %
                 (llxsubdir, commondir))
            tar.extractall(path=homedir, members=commonmembers)
        devel('standardmembers', standardmembers)
        if standardmembers:
            info('Extracting project files, currentdir "%s"' %
                  os.getcwd())
            tar.extractall(path='.', members=standardmembers)
    return 0


def addHighLightDef(destDict, mac, colordefs):
    """Add definition for color highlighting into given dict

    """
    (color, defs) = colordefs.split('-',1)
    if not color in dviPsColors and not color in stdColors:
        error('Invalid color name specified: "%s"' % color)
        sys.exit(1)
    if defs:
        keywords = defs.split(',')
        for keyword in keywords:
            for bracket in pCurly.keys():
                keyword = keyword.replace(bracket, pCurly[bracket])
            if not keyword in destDict.keys():
                destDict[keyword] = color
            else:
                warn('Keyword "%s" already in highlighting with color "%s", '
                     'skipping...' %
                     (keyword, destDict[keyword]))
    else:
        debug('Color definition "%s" w/o keywords' % color)
    if not mac in destDict.keys():
        destDict[int(mac)] = color
    #else:
    #    warn('Macro "%s" already in highlighting with color "s", skipping...' %
    #         (mac, destDict[mac]))


def handleTableSpecifics(line):
    """Handle keywords within table definition

    Returns 1, if any known keyword is found
    """
    global tabSortBy
    global tabColSort
    tabspecials = ('SORTBY', 'COLORDER')
    for keyword in tabspecials:
        Match = re.match(r'^' + keyword + '\s*(.*)$', line)
        if Match:
            if len(workTableList) > 0:
                error('Table %s statement must appear BEFORE first data' %
                      keyword)
                return 1
            if keyword == 'SORTBY':
                tabSortBy = re.sub(r'\s+$', '', Match.group(1))
                debug('Table %s: "%s"' % (keyword, tabSortBy))
                return 1
            elif keyword == 'COLORDER':
                tabColSort = re.sub(r'\s+$', '', Match.group(1))
                debug('Table %s: "%s"' % (keyword, tabColSort))
                return 1
            else:
                warn('Not sure how to handle keyword %s' %
                     keyword)
    return 0


def processLtx(fname):
    """Process a given LTX file

    This function performs the actual processing of a source file. It is
    designed to be recursive, which allows for include of other llx files.
    """
    global author
    global docHead
    global heading
    global docVersion
    global versionedFileName
    global llxStack
    global tabFileContents
    global workList
    global workVerbatim
    global imgcount
    global tabcount
    global workTableList
    global haveAppendix
    global haveHistory
    global hstNewComment
    global docHistory
    global currentHeading
    global labels
    #tablerow = 0
    global verbatimline
    global verbatimcount
    global warnV
    global isHidden
    global isInList
    global tabLineSep
    global tabSortBy
    global tabColSort
    global tabHLight
    global defHLight
    global endedBlock
    global vFontSize
    debug('Entered processLtx() for "%s"' % fname)
    llxTables[fname] = {}
    tablerow = 0
    with codecs.open(fname, 'r', encoding='utf-8') as FH:
        debug('LTX DEPTH LEVEL: %d' % (len(llxStack)-2))
        devel('LTX opened, llxStack contents', llxStack)
        vardict['LTXFILE'] = llxStack[-1]['llx']
        if len(llxStack) < 3:
            vardict['LTXMASTER'] = llxStack[-1]['llx']
        #devel('entered llx %s, vardict is' % llxStack[-1]['llx'], vardict)
        skipMarker = 0
        for line in FH:
            llxStack[-1]['llxLineNum'] += 1
            # ALLOW for 'full' llx includes, which needs to skip some stuff
            # TODO: here, TAB section is special now, it allows some variables
            # to be defined (per table hightlight)
            if len(llxStack) > 2:
                line = re.sub('\n', '', line)
                # TODO: we might need to keep color definition variables for
                #       each llx file locally. Later: per table local def
                # For now: user defined variables in included llx are added
                Match = _VAR_.match(line)
                if Match:
                    value = ''
                    if Match.group('VARNAME'):
                        name = Match.group('VARNAME')
                        if name.startswith('$'):
                            debug('Skipping commented var "%s" within '
                                  'included llx file' % name)
                            continue
                        # skip color value definitions
                        elif re.match(r'[0-9]{1}', name):
                            # within tables: these are per table highlights
                            if getCurrentBlock() == 'TAB':
                                if Match.group('VALUE'):
                                    value = Match.group('VALUE')
                                    addHighLightDef(tabHLight, name, value)
                                    devel('DEFINE SPECIFIC HLIGHT', tabHLight)
                            else:
                                devel('skipping color var "%s" within '
                                      'included llx file' % name)
                                continue
                        else:
                            if not name in vardict.keys():
                                if Match.group('VALUE'):
                                    value = Match.group('VALUE')
                                    vardict[name] = value
                                    debug('Adding variable "%s=%s" from '
                                          'within included llx file' %
                                          (name, value))
                                    devel('vardict contents', vardict)
                            else:
                                # TODO: use list of reserved variable names
                                if name == 'LTXFILE':
                                    warn('Variable name "%s" is reseved, '
                                         'use other name' % name)
                                else:
                                    debug('Variable "%s" already in dict, '
                                          'will not overwrite' % name)
                    continue
                #if re.match(r'(^[\d\.]+#.*#.*#.*|^%%HST)',line):
                if re.match(r'(^%%HST)', line):
                    skipMarker = 1 - skipMarker
                    devel('LTX INCLUDE: ignoring history macro - "%s"' % line)
                    continue
                # BUGFIX: matching bad - old re.match also skipped things like
                #         %%CODE3 python#Function devel()#labcode
                #         old match: if re.match(r'(^.*#.*#.*|^%%LIT)',line):
                # TODO: make this with a list of macros to skip in single call
                if re.match(r'(%%LIT)', line):
                    skipMarker = 1 - skipMarker
                    devel('LTX INCLUDE: ignoring literature macro - "%s"' %
                          line)
                    continue
                if skipMarker:
                    devel('LTX INCLUDE: ignoring line - "%s"' % line)
                    continue
                # check for duplicate APP statement anyway within later code,
                # so this actually could be removed - we keep it for safety
                if re.match(r'(^%%APP.*)', line):
                    devel('LTX INCLUDE: ignoring APP statement - "%s"' % line)
                    continue

            # TODO what about warning for possible typos, e.g. %V instead %%V
            # btw: think of general simplification and allow single % in macros
            # this is not yet complete..., also upper/lower case handling
            typolist = ('%V', '%L', '%HREF')
            for typo in typolist:
                if line.startswith(typo):
                    warn('Possible typo "%s", correcting to "%%%s"...' %
                         (typo, typo))
                    line = re.sub(r'^' + typo, '%'+typo, line)

            if (isInList and not
               re.match(r'^%%NL.*', line) and not
               re.match(r'^%%INC.*', line)):
                isInList = 0

            #if heading and re.match(r'^%%H.*', line):
            if heading and re.match(r'^%%H\d+', line):
                warn('Stacked heading detected ...')
            if (heading and not
               re.match(r'^\s$', line) and not
               re.match(r'^%%INC.*', line) and not
               re.match(r'^%%NL.*', line) and not
               re.match(r'^\$\$.*', line)):
                heading = 0

            if isHidden and not options.private and not _HIDE_.match(line):
                continue

            line = re.sub('\n', '', line)

            # TODO: better just process the line for possible verbatim
            #       so nothing gets interpreted...
            # The RUN macro has been already added - still undocumented
            if getCurrentBlock() == 'V' and not line.startswith('%%RUN'):
                if not re.match(r'^%%[Vv].*', line):
                    if not re.match(r'^%%INC.*', line):
                        makeVerbatim(line)
                        # %%macros within verbatim could be an indicator for
                        # unclosed verbatim sections. These would crash later
                        # so warn here. At end of document, a check for closed
                        # verbatim is done
                        if line.startswith('%%') and warnV == 0:
                            warn('LaLaTeX Macro within verbatim - might be '
                                 'an unclosed verbatim section')
                            warnV = 1
                        continue

            # Check for any non-allowed escaped characters
            line = chkEscape(line)

            # Curly bracket handling with makedoc with color for sample tables.
            # FIX: curly brackets in run are needed
            if (not getCurrentBlock() in ('V','CODE') and not
                line.startswith('%%RUN') and not
                line.startswith('$$') and not
                'EXAMPLE TEXT for LaLaTeX Coloring in' in line and not
                re.match(r'^\$\d\$', line)):
                if line:
                    line = handleCurly(line)

            # More: '&&' could be a typo if at line start...

            # $VAR stuff in development - using replacement function makeVar()
            line = re.sub('(\$)([^\s,\.}]+)', makeVar, line)

            # Table sort feature - if SORTBY string found within tab...
            # Must appear BEFORE any table contents, not being special
            # statements like $VAR$...
            # per table highlight is next to go here...
            if getCurrentBlock() == 'TAB':
                handleTableSpecifics(line)

            # -----------------------------------------------------------------
            # Match for Variable macro setting
            Match = _VAR_.match(line)
            if Match:
                # TODO: rework - value =match... if not value:  else:
                value = ''
                if Match.group('VARNAME'):
                    name = Match.group('VARNAME')
                    if name.startswith('$'):
                        info('Variable "%s" commented out' %
                             name)
                        continue
                # TODO - this check could be removed, in INC processing now
                if llxStack[-1]['llx'] != os.path.abspath(baseLtxFileName +
                                                          '.llx'):
                    warn('VAR "%s" - no VAR allowed witin included llx files, '
                         'ignoring...' % name)
                    continue
                if Match.group('VALUE'):
                    value = Match.group('VALUE')
                else:
                    if name == 'CUST':
                        warn('No value for Customer Name, leaving empty')
                        value = ''
                    elif name == 'PROJ':
                        warn('No value for Project Name, leaving empty')
                        value = ''
                    elif name == 'VERS':
                        error('Missing value for Document Version')
                        sys.exit(1)
                        value = ''
                    elif name == 'WATERMARK':
                        info('No watermark content specified...')
                        value = ''
                    elif name == 'LEFTLOGO':
                        value = defLeftLogo
                    else:
                        error('No value for variable "%s"' % name)
                        exit()
                if name == 'WATERMARK':
                    if value != 'none' and value != '':
                        value = re.sub('TEXT', value, watermark)
                    else:
                        value = ''
                elif name == 'CUST':
                    vardict[name] = value
                    customer = re.sub(r'([_&%$#])', esc, value)
                elif name == 'PROJ':
                    # for the $VAR stuff: need unescaped version as key!!!
                    # otherwise crash
                    vardict[name] = value
                    value = re.sub(r'([_&%$#])', esc, value)
                elif name == 'AUTH':
                    author = value
                elif name == 'VERS':
                    if not re.match('^\d{1,2}(\.\d{1,2}){0,3}$', value):
                        error('BAD version "%s", must be "nn[.nn.nn.nn]" ...' %
                              value)
                        sys.exit(1)
                    vardict[name] = value
                    versionedFileName = '%s-v%s' % (baseLtxFileName, value)
                    debug('Found Document version "%s", creating "%s.pdf"' %
                          (value, versionedFileName))
                    docVersion = value
                elif name == 'TSEP':
                    if value != tabLineSep:
                        info('Replacing default TSEP "%s" by "%s"' %
                             (tabLineSep, value))
                        tabLineSep = value
                elif name == 'LEFTLOGO' or name == 'CUSTLOGO':
                    debug('Logo definition: "%s"' % value)
                    if name == 'LEFTLOGO':
                        debug('Actual left logo: %s' % value)
                        debug('Default left logo: %s' % defLeftLogo)
                    # TODO: LOGO Path with new findFile
                    if os.path.exists(value):
                        addResource(os.path.abspath(value),
                                    llxStack[-1]['llx'],
                                    'logo')
                        value = '\includegraphics[height=0.8cm]{%s}' % value
                    elif os.path.exists(commondir + '/' + value):
                        addResource(commondir + '/' + value,
                                    llxStack[-1]['llx'],
                                    'logo')
                        value = '\includegraphics[height=0.8cm]{%s/%s}' % \
                                (commondir, value)
                    else:
                        warn('File "%s" not found, replacing by "%s" from '
                             '$CUST$ variable' % (value, customer))
                        if name == 'CUSTLOGO':
                            value = customer
                        else:
                            value = '\\colorbox{yellow}{Missing %s}' % value
                # Text color highlighting in tables
                elif re.match(r'^[0-9]{1}$', name):
                    devel('table-highlight macro %s, value %s' % (name, value))
                    # TODO - work on syntax for just a color with no keywords
                    #        is - ok? what if keyword contains -? split on
                    #        first only or better have no minus?
                    if getCurrentBlock() == 'TAB':
                        addHighLightDef(tabHLight, name, value)
                        devel('DEFINE SPECIFIC HLIGHT', tabHLight)
                    else:
                        addHighLightDef(defHLight, name, value)
                        devel('DEFINE DEFAULT HLIGHT', defHLight)

                docHead = re.sub('\$' + name + '\$', value, docHead)

                # $VAR - fill in vardict, but do NOT fill highlighting macros
                if not re.match(r'^\d$', name) and not name in vardict.keys():
                    debug('Adding variable "%s" to variable dict with value '
                          '"%s"' % (name, value))
                    vardict[name] = value
                # warn for duplicates, but some need to be excluded from this
                elif (not re.match(r'^\d$', name) and not
                      name in ('VERS', 'CUST', 'PROJ')):
                    warn('Duplicate variable found: $%s$' % name)
                # TODO: check for macros used more than once
                continue

            # -----------------------------------------------------------------
            # Match for a list element
            # NOTE: when modifying the code, keep this on top of the matches
            # TODO: needs rework, from type of lists and logic point of view
            # TODO: L macro with no space to text
            # TODO: warn for mix of type within one list and make the first
            #       entry define the type of list
            Match = _L_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                if macro == 'l':
                    debug('Detected "%%l" - most likely a typo, replacing '
                          'by "%%L"')
                    macro = 'L'
                lType = Match.group('TYPE')
                if not lType:
                    debug('Detected "%%L" - no list type, assuming "%%L1"')
                    lType = '1'
                elif lType == '!':
                    debug('Detected "%%L!" - typo, replacing by "%%L1"')
                    lType = '1'
                if not lType in ('1', 'n'):
                    error('Bad type %s for list, only L1 and Ln supported' %
                          lType)
                    sys.exit(1)
                if not Match.group('CONTENT'):
                    error('Missing list element content')
                else:
                    workList.append(Match.group('CONTENT'))
                    isInList = 1
                    enterBlock(macro)
                    continue
            elif getCurrentBlock() == 'L':
                # NEW Logic 2015-01-16-22-15:
                # if starts with %% - finalize list and proceed processing
                # if empty line     - finalize list and 'continue' 
                # if comment:       - skip (continue) - check, is already done
                # normal text:      - append to current element text
                if (line.startswith('%%') or
                    line.isspace() or
                    line == ''):
                    debug('Finalizing list...')
                    if len(workList) > 0:
                        createList(lType, workList)
                        workList = []
                        leaveBlock()
                    if line.isspace() or line == '':
                        continue
                else:
                    if not line.startswith('$$'):
                        workList[-1] += ' ' + line
                        continue

            # -----------------------------------------------------------------
            # Match for heading line (H1 - H5)
            Match = _H_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                hLevel = Match.group('LEVEL')
                if not hLevel.isdigit():
                    error('Non digit heading level %s detected' % hLevel)
                    sys.exit(1)
                else:
                    if not Match.group('CONTENT'):
                        error('Missing title in heading')
                        exit(1)
                    else:
                        debug('Match: %s' % (re.sub('%%', '', line)))
                        currentHeading = createHeading(int(hLevel),
                                                       Match.group('CONTENT'))
                        heading = 1
                continue

            # -----------------------------------------------------------------
            # Match for 'verbatim'
            # TODO: shaded basically ok, but additional line at start and end!!
            #       how to remove this. comes from verbatim some way...
            #       see: http://tex.stackexchange.com/questions/180572/how-to-
            #            avoid-the-empty-lines-before-and-after-a-verbatim-
            #            environment-in-a-tabula
            #       BVerbatim: good for short ones, but not page spanning !!!
            #       \verb: test this
            # this seems to work, see testb.tex
            # \begin{shaded}
            # \noindent
            # \verb|text in verb| \\
            # \verb|text \wie in verb|
            # \end{shaded}
            Match = _V_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                # TODO - later, just silently convert without any message
                if macro == 'v':
                    warn('Detected "%%v" - typo, replacing by "%%V"')
                    macro = 'V'
                #vFontSize = Match.group('FONTSIZE')
                cB = getCurrentBlock()
                if cB != macro:
                    vFontSize = Match.group('FONTSIZE')
                    if not vFontSize:
                        debug('Assuming verbatim font size "%d" as default' %
                              defVrbFontSize)
                        vFontSize = str(defVrbFontSize)
                    enterBlock(macro)
                    verbatimline = 0
                    verbatimcount = 0
                    workVerbatim = []
                elif cB == macro:
                    if isHidden:
                        docBody.append('\\definecolor{shadecolor}{rgb}'
                                       '{1.0,0.95,0.95}')
                        docBody.append('\\color{texthidden}')
                    if not verbatimcount:
                        docBody.append('\\definecolor{shadecolor}{rgb}'
                                       '{1.0,0.11,0.11}')
                    docBody.append('%s\n'
                                   '\\begin{shaded}\n'
                                   '\\noindent' %
                                   fsize[int(vFontSize)])
                    if not verbatimcount:
                        error('Closing VERB - but no content within the block')
                        # TODO: make this a verbatim with info about cause
                        #       need a variable for this
                        docBody.append('\\verb|====  EMPTY VERBATIM BLOCK!!  ====|')
                    else:
                        # uuid shorten etc.. - should be placed here if at all
                        for vEntry in workVerbatim:
                            docBody.append(vEntry)
                    docBody.append('\\end{shaded}\n'
                                   #'\\noindent\n'
                                   '%s%s' %
                                   (ffamily[defFont], fsize[defFontSize]))
                    if isHidden or not verbatimcount:
                        docBody.append('\\definecolor{shadecolor}{rgb}'
                                       '{0.95,0.95,0.95}')
                        docBody.append('\\color{black}')
                    leaveBlock()
                    debug('%d lines (%d non space) written to verbatim block' %
                          (verbatimline, verbatimcount))
                    verbatimline = 0
                    verbatimcount = 0
                    workVerbatim = []
                    endedBlock = macro
                else:
                    error('Macro "%s": called within %s' %
                          (macro, cB))
                continue

            # -----------------------------------------------------------------
            # Match a table start/end
            Match = _TAB_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                if getCurrentBlock() != macro:
                    if isHidden:
                        docBody.append('\\color{texthidden}')
                    tabfont = ffamily[defTabFont]
                    tabfontsize = fsize[defTabFontSize]
                    tabData = {}
                    tabData['csvsep'] = defCsvSep
                    if Match.group('CAPTION'):
                        caption = Match.group('CAPTION')
                        tabData['caption'] = caption
                    else:
                        warn('Table without caption...')
                        # switch over to soul package hl command - test
                        tabData['caption'] = '\\hl{missing table caption}'
                        caption = ''
                    if Match.group('LABEL'):
                        label = Match.group('LABEL')
                        if label in labels:
                            error('Label "%s" already in use in %s.llx, line %d' %
                                  (label,
                                   labels[label]['file'],
                                   labels[label]['line']))
                            label = '@' + label
                        else:
                            labels[label]['code2'] = ('\emph{Table \\ref{%s}}' %
                                                      label)
                            # caption as default replacement text
                            labels[label]['text'] = caption
                            labels[label]['line'] = llxStack[-1]['llxLineNum']
                            labels[label]['file'] = llxStack[-1]['llxBase']
                            debug('Label: "%s", caption "%s"' % (label, caption))
                        tabData['label'] = label
                    else:
                        debug('Table has no label, caption "%s"' % caption)
                        tabData['label'] = ''
                    debug('TAB block starting')
                    if Match.group('FLAGS'):
                        flags = Match.group('FLAGS')
                        debug('Flags: "%s"' % flags)
                        for flag in flags:
                            if flag == 'A':
                                debug('Creating table with alternating row colors')
                            elif flag == 'H':
                                debug('Creating table with auto highlighting')
                            elif flag == 'B':
                                todo('Bulk table loading not implemented')
                            elif flag == 'S':
                                todo('Scaling table deactivated again - TBD')
                            elif flag.isdigit():
                                tabfontsize = fsize[int(flag)]
                                debug('Setting table font size to "%s"' %
                                      tabfontsize)
                            elif flag in ('s', 't', 'r'):
                                tabfont = ffamily[flag]
                                debug('Setting table font familiy to "%s"' %
                                      tabfont)
                            elif flag in (';', ',', ':'):
                                debug('Setting CSV separator to "%s"' %
                                      flag)
                                #csvSep = flag
                                tabData['csvsep'] = flag
                            else:
                                warn('Unknown flag "%s" for table' % flag)
                    else:
                        flags = ''
                    #tabData['csvsep'] = csvSep
                    tabData['font'] = tabfont
                    tabData['fontsize'] = tabfontsize
                    tabData['flags'] = flags
                    tablerow = 1
                    tablecol = 0
                    tabcount += 1
                    llxStack[-1]['llxTabCount'] += 1
                    workTableList = []
                    tabHLight = {}
                    tabSortBy = ''
                    tabColSort = ''
                    enterBlock(macro)
                else:
                    # NEW: process the workTableList/Dict here. This contains
                    # ALL!! lines now, also those from INC, RUN and lines in
                    # the llx file itself
                    #llxTables[fname].append(tabData)
                    tabData['count'] = tabcount
                    if tabHLight:
                        info('This table has its own highlighting defs...')
                        devel('TABHLIGHT', tabHLight)
                    else:
                        tabHLight = defHLight
                    llxTables[fname]['tabdata'] = tabData
                    # 1. write first line as header
                    # 2. check, if sorted
                    # 3a. if yes: write rest starting at idx 1 with sort logic
                    # 3b. if no: write rest starting at idx 1 with no sort
                    # TODO bugfix, catch empty worktablelist !!
                    if workTableList:
                        makeTableRow(docBody,
                                     tabData['csvsep'].join(workTableList[0]),
                                     1,
                                     llxTables[fname])
                    else:
                        error('Empty table!')
                        makeTableRow(docBody,
                                     '\\textbf{Missing table contents}',
                                     1,
                                     llxTables[fname])
                    tablerow += 1
                    devel('TABLE DATA', tabData)
                    if tabSortBy:
                        info('TAB closing, write sorted table')
                        devel('workTableList', workTableList)
                        slist = sorted(workTableList[1:],
                                       key=itemgetter(tabData['sortidx']))
                        for incline in slist:
                            makeTableRow(docBody,
                                         tabData['csvsep'].join(incline),
                                         tablerow,
                                         llxTables[fname])
                            tablerow = tablerow + 1
                    else:
                        info('TAB closing, write unsorted table contents')
                        for incline in workTableList[1:]:
                            makeTableRow(docBody,
                                         tabData['csvsep'].join(incline),
                                         tablerow,
                                         llxTables[fname])
                            tablerow = tablerow + 1
                    workTableList = []

                    debug('TAB block ending (%d rows including header)' %
                          (tablerow-1))
                    tabwidth = 'textwidth'
                    if 'LAND' in currentBlock:
                        tabwidth = 'linewidth'
                    docBody.append('\end{longtable}\n'
                                   '\end{filecontents*}\n'
                                   #'\LTXtable{\\%s}{%s}\n'
                                   #'\\noindent' %
                                   '\LTXtable{\\%s}{%s}\n' %
                                   (tabwidth,
                                    tabFileContents))
                    if isHidden:
                        docBody.append('\\color{black}')
                    caption = ''
                    label = ''
                    tablerow = 0
                    tablecol = 0
                    tabfont = ffamily[defTabFont]
                    tabfontsize = fsize[defTabFontSize]
                    endedBlock = macro
                    leaveBlock()

                continue

            # -----------------------------------------------------------------
            # Match an include
            # Includes are possible for
            # 1. simple text
            # 2. within verbatim blocks (no '_' escaping)
            # 3. within tables ('_' needs escape as well)
            # 4. within inline code, needs escaping as well
            # 5. llx file includes: search current dir, then lalatex common dir
            #    TODO: recursion check: maybe skip instead of stopping
            Match = _INC_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                if Match.group('INCFILE'):
                    incFile = Match.group('INCFILE')
                    fileName = incFile
                    debug('INC: ' + incFile)
                else:
                    error('Macro "%s": a file name must be specified' %
                          macro)
                    sys.exit(1)
                cB = getCurrentBlock()
                if not cB == 'V' and not cB == 'CODE':
                    docBody.append('%% Start include from ' + incFile)
                if cB == 'CODE':
                    defPath = srcDefaultDir
                elif cB == 'TAB':
                    defPath = tabDefaultDir
                else:
                    # this might be an llx file, or include in verbatim or just
                    # unstructured text...
                    defPath = ''

                searchpaths = getPathList(incFile, defPath)
                devel('calling findFile for "%s" with search' % incFile,
                      searchpaths)
                incFile = findFile(incFile, searchpaths)

                if incFile:
                    if '.llx' in incFile:
                        fullInc = os.path.abspath(incFile)
                        info('Calling processLtx() for include file "%s", '
                             'full path "%s"' % (incFile, fullInc))
                        devel('llxStack: ', llxStack)
                        # TODO: keep rel path for the llx include to use for
                        #       searches to images included by thie llx file.
                        # main document should be able to find these as well
                        #incFileBaseName = os.path.basename(incFile)
                        for element in llxStack:
                            if fullInc in element['llx']:
                                error('ENDLESS INCLUDE RECURSION FOR "%s", '
                                      'exiting' % fullInc)
                                todo('Maybe more infos about includes nesting')
                                sys.exit(1)
                        llxStack.append({'llx': fullInc,
                                         'llxBase': re.sub('.llx', '', incFile),
                                         'logName': incFile,
                                         'llxLineNum': 0,
                                         'llxTabCount': 0})
                        addResource(fullInc, llxStack[-2]['llx'], 'llxfile')
                        processLtx(incFile)
                    else:
                        # non-llx include: currently only with V, CODE and TAB
                        # TODO: check section FIRST before opening file
                        # TODO: verify use of utf-8-sig explicitly here to
                        # remove the BOM from included files
                        #with open(incFile,'r') as INC:
                        # TODO: check use of python csv - the sniff class might
                        # be interesting and handling of quote detection
                        with codecs.open(incFile, 'r',
                                         encoding='utf-8-sig') as INC:
                            lc = 1
                            for fileLine in INC:
                                fileLine = re.sub('\n', '', fileLine)
                                if (not cB == 'V' and not
                                    cB == 'CODE' and not
                                    cB == 'TAB'):
                                    fileLine = re.sub('_', '\_', fileLine)
                                if cB == 'TAB':
                                    if re.match('^\$\$', fileLine):
                                        continue
                                    if handleTableSpecifics(fileLine):
                                        debug('returned 1 from tab specifics')
                                        continue
                                    # TODO highlight statements within include
                                    hlmatch = re.match(r'^\$(\d)\$\s+(.*)$',
                                                       fileLine)
                                    if hlmatch:
                                        addHighLightDef(tabHLight,
                                                        hlmatch.group(1),
                                                        hlmatch.group(2))
                                        debug('Color Highlight within include')
                                        devel('DEFINE SPECIFIC HLIGHT',
                                              tabHLight)
                                    else:
                                        if not addTableWorkContents(fileLine,
                                                                    tabData):
                                            # TODO: PRINT RANGE for short log
                                            error('... above error is in line %d in "%s"' %
                                                  (lc, incFile))
                                elif cB == 'V':
                                    if fileLine.startswith('%%V'):
                                        debug('%%V macro within non llx include file %s' %
                                              incFile)
                                    makeVerbatim(fileLine)
                                elif cB == 'CODE':
                                    docBody.append(fileLine)
                                else:
                                    warn('INC for "%s" out of V/CODE/TAB' %
                                         incFile)
                                    break
                                lc += 1
                        addResource(os.path.abspath(incFile),
                                    llxStack[-1]['llx'],
                                    'nonllxinc')
                else:
                    error('Include file "%s" could not be located.' %
                          Match.group('INCFILE'))
                    if cB == 'CODE':
                        docBody.append('MISSING CODE FROM INCLUDE FILE "%s"' %
                                       fileName)
                    elif cB == 'V':
                        makeVerbatim('MISSING DATA FROM INCLUDE FILE "%s"' %
                                     fileName)
                    elif cB == 'TAB':
                        # how could we append something useful here?
                        pass
                    # TODO: works in Verbatim, but problems in normaltext....
                if not cB in ('V', 'CODE', 'TAB'):
                    docBody.append('%% End include from ' + incFile)
                if not tablerow:
                    continue

            # ----------------------------------------------------------------------
            # Match for an IMAGE include
            Match = _IMG_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                if 'LAND' in currentBlock:
                    imgSizeMax = defImageSizeL
                else:
                    imgSizeMax = defImageSizeP
                if not Match.group('SIZE'):
                    imgSize = imgSizeMax
                    info('IMG macro with no size, using %scm default width' %
                         imgSize)
                else:
                    imgSize = Match.group('SIZE')
                    if int(imgSize) > int(imgSizeMax):
                        warn('Image width of %s cm too wide, limiting to %s cm...' %
                            (imgSize, imgSizeMax))
                        imgSize = imgSizeMax

                imgFile = Match.group('IMGFILE')
                if not imgFile:
                    warn('IMG macro with no Image, skipping...')
                    continue

                fileName = imgFile
                searchpaths = getPathList(imgFile, 'images')

                devel('calling findFile for "%s" with search' % imgFile,
                      searchpaths)
                imgFile = findFile(imgFile, searchpaths)

                if not imgFile:
                    error('Missing Image file "%s" - creating warning box' %
                          fileName)
                    makeWarningBox(docBody, 'Image file "%s" not found' %
                                   fileName)
                    continue
                else:
                    info('Finally using image file "%s"' % imgFile)
                    gifName = ''
                    if imgFile.endswith('.gif') or imgFile.endswith('.GIF'):
                        # GIF: not supported with pdflatex. Conversion needed
                        # 1. Use latex methods (get infos from celsius workstation)
                        # 2. Use 'pythonmagick' or 'wand' python packages
                        #    - needs extra installation, not in openclient repos
                        # 3. Use subprocess.Popen() - done for now
                        todo('Use pythonmagic/wand for gif->png conversion?')
                        gifName = imgFile
                        # TODO: need to detect change in png - use md5 in name
                        imgFile = re.sub(r'\.(gif|GIF)$', '-gif', imgFile) + '.png'
                        if os.path.exists(imgFile):
                            debug('Using already converted file "%s"' %
                                  imgFile)
                        else:
                            if haveMagick:
                                warn('File "%s" needs to be converted to "%s" '
                                     'before processing' %
                                     (gifName, imgFile))
                                #imgFile = re.sub(r'\.\w{3}$','.png',imgFile)
                                runCmd = ('convert ' + gifName + ' ' +
                                          re.sub(r'\.\w{3}$', '.png', imgFile))
                                debug('running "%s"' % runCmd)
                                childProcess = subprocess.Popen(runCmd, shell=True,
                                                                stdout=subprocess.PIPE,
                                                                stderr=subprocess.PIPE)
                                #StdOut, StdErr = childProcess.communicate()
                                runFailed = childProcess.returncode
                                if runFailed:
                                    error('image convert failed')
                                    sys.exit(1)
                                else:
                                    info('Image conversion done')
                            else:
                                error('GIF File cannot be handled, need '
                                      'ImageMagick installed')
                                sys.exit(1)

                if Match.group('CAPTION'):
                    caption = re.sub(r'([_&%$#])', esc, Match.group('CAPTION'))
                else:
                    warn('Image without caption...')
                    missing_caption = '\\hl{missing image caption}'
                    caption = ''

                if Match.group('LABEL'):
                    label = Match.group('LABEL')
                    if label in labels:
                        error('Label "%s" already in use in %s.llx, line %d' %
                              (label,
                               labels[label]['file'],
                               labels[label]['line']))
                        label = '@' + label
                        labelinfo = ''
                    else:
                        labels[label]['code2'] = '\emph{Figure \\ref{fig:%s}}' % label
                        # caption as default replacement text
                        labels[label]['text'] = caption
                        labels[label]['line'] = llxStack[-1]['llxLineNum']
                        labels[label]['file'] = llxStack[-1]['llxBase']
                        labelinfo = '\\label{fig:%s}' % label
                        debug('Label: "%s", caption "%s"' % (label, caption))
                else:
                    labelinfo = ''
                    label = 'none'
                    debug('Image has no label, caption "%s"' % caption)

                imgcount += 1
                debug('Image "%s", size=%s cm, caption="%s", label="%s"' %
                      (imgFile, imgSize, caption, label))
                if caption:
                    docBody.append('\\begin{figure}[H]\n'
                                   '\\centering\n'
                                   '\\includegraphics[width=%scm]{%s}\n'
                                   '\\caption{%s}'
                                   '%s'
                                   '\\end{figure}' %
                                   (imgSize, imgFile, caption, labelinfo))
                else:
                    docBody.append('\\begin{figure}[H]\n'
                                   '\\centering\n'
                                   '\\includegraphics[width=%scm]{%s}\n'
                                   '\\caption{%s}'
                                   '%s'
                                   '\\end{figure}' %
                                   (imgSize,
                                    imgFile,
                                    missing_caption,
                                    labelinfo))
                label = ''
                endedBlock = macro
                addResource(os.path.abspath(imgFile),
                            llxStack[-1]['llx'],
                            'image')
                if gifName:
                    addResource(os.path.abspath(gifName),
                                llxStack[-1]['llx'],
                                'image')
                continue

            # -----------------------------------------------------------------
            # Match for SRC listing include - create listings section from all
            # files in specific subdirectory or from the given file
            # Labels are assigned to the heading, using the filename.
            # TODO - wildcard match for source files useful? We can handle this
            #        by placement in subdirectories
            Match = _SRC_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                #line = re.sub('_','\_',line)
                debug('SRC listing to include at heading level %s' %
                      currentHeading)
                if not haveAppendix:
                    # bulk listings should go into the appendix...
                    warn('SRC statement outside of APPENDIX - are you sure?')
                fileList = []
                dir = ''
                incList = Match.group('PATH')
                if incList == '':
                    incList = srcDefaultDir
                if not os.path.exists(incList):
                    warn('SRC file or directory "%s" not found - skipping' %
                         incList)
                    continue
                if os.path.isdir(incList):
                    dir = incList + '/'
                    debug('Directory: ' + dir)
                    for subdir, dirs, files in os.walk(incList):
                        for file in files:
                            debug('  Found file :' + file)
                            # only append, if subdir is equal to incList
                            if subdir == incList:
                                fileList.append(file)
                                debug(' Appending file "%s" into include, '
                                      'found in "%s"' %
                                      (file, incList))
                            else:
                                debug(' Skipping file "%s" from include, '
                                      'directory "%s" not matching "%s"' %
                                      (file, subdir, incList))
                else:
                    filepath = incList.rsplit('/', 1)
                    if len(filepath) > 1:
                        dir = filepath[0] + '/'
                        fileList.append(filepath[1])
                    else:
                        dir = ''
                        fileList.append(filepath[0])
                if len(fileList) == 0:
                    warn('Macro "%%%%SRC" found, but directory "%s" is empty' %
                         incList)
                for file in fileList:
                    debug('SRC: ' + file)
                    lang = getScriptType(dir + file)
                    if lang == 'UNKNOWN':
                        error('File %s: does not match any known language, '
                              'skipping.' % (dir + file))
                    else:
                        if currentHeading < maxHeading:
                            createHeading(currentHeading+1, 'Listing of %s#%s'
                                          % (file, file))
                        else:
                            warn('Heading limit reached for listing, keeping level')
                            createHeading(currentHeading, 'Listing of %s#%s'
                                          % (file, file))
                        md5 = hashlib.md5(open(dir + file, 'rb').read()).hexdigest()
                        ### NEW, check: TODO: underscore in filename fails
                        docBody.append('\scriptsize'
                                       '\\texttt{MD5SUM for this listing is %s}\small\n'
                                       % md5)
                        docBody.append('\\lstinputlisting\n'
                                       '[caption = {Listing of %s},language=%s]\n'
                                       '{%s}'
                                       % (re.sub('_', '\_', file),
                                          lang,
                                          dir + file))
                        addResource(os.path.abspath(dir + file),
                                    llxStack[-1]['llx'],
                                    'src')
                continue

            # -----------------------------------------------------------------
            # Match for inline code listing
            # %%CODE#language#caption text#label
            # \begin{lstlisting} [caption = caption, captionpos=b, label=label,
            # language=python]{}
            # code here
            # \end{lstlisting}
            Match = _CODE_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                if getCurrentBlock() != macro:
                    if Match.group('FONTSIZE'):
                        cFontSize = Match.group('FONTSIZE')
                    else:
                        info('No fontsize for CODE block, defaulting to "2"')
                        cFontSize = str(defCodFontSize)
                    inlineLang = Match.group('LANG')
                    if Match.group('CAPTION'):
                        caption = Match.group('CAPTION')
                        caption = re.sub('_', '\_', caption)
                        if caption in captions:
                            error('Caption "%s" for CODE already used in line %d' %
                                  (caption, captions[caption]))
                        else:
                            debug('Caption "%s" for inline code' %
                                  caption)
                            captions[caption] = llxStack[-1]['llxLineNum']
                    else:
                        caption = ''
                    label = ''
                    if Match.group('LABEL'):
                        # TODO: trailing blanks on label can be evil :)
                        label = Match.group('LABEL')
                        if label in labels:
                            error('Label "%s" already in use' % label)
                            label = ''
                        else:
                            debug('Label "%s" for inline code' % label)
                            labels[label]['code2'] = '\emph{Listing \\ref{lst:%s}}' % label
                            labels[label]['text'] = caption
                            labels[label]['line'] = llxStack[-1]['llxLineNum']
                            labels[label]['file'] = llxStack[-1]['llxBase']
                            label = 'label=lst:%s,' % label
                    debug('Entering inline code listing, language "%s"' %
                          inlineLang)
                    docBody.append('\\begin{lstlisting}'
                                   '[caption = %s,'
                                   'captionpos=b,'
                                   'basicstyle=\\ttfamily%s,'
                                   'numberstyle=\\ttfamily\\tiny,'
                                   '%s'
                                   'language=%s]{}\'' %
                                   (caption,
                                    fsize[int(cFontSize)],
                                    label,
                                    inlineLang))
                    enterBlock(macro)
                else:
                    debug('Leaving inline code listing')
                    docBody.append('\\end{lstlisting}')
                    leaveBlock()
                    label = ''
                    caption = ''
                continue

            # -----------------------------------------------------------------
            # Match for block %%NOTE, %%WARN, %%TIP, %%TODO
            # TODO: no newline allowed after end bar - need to check this
            # TODO: use textsf for this - would be better
            Match = _NOTE_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                #if Match.group('FONTSIZE'):
                #    vFontSize = Match.group('FONTSIZE')
                #else:
                #    vFontSize = '3'
                cB = getCurrentBlock()
                if isHidden:
                    macro = 'H' + macro
                if cB is None or cB == 'HIDE' or cB == 'LAND':
                    debug('Entering "%s" block' % macro)
                    docBody.append('\\begin{%s}\n\%s\\\\' %
                                   (macro.lower(), macro))
                    enterBlock(macro)
                elif cB == macro:
                    debug('Leaving "%s" block' % macro)
                    #docBody.append('\\end{%s}\\noindent' % macro.lower())
                    docBody.append('\\end{%s}' % macro.lower())
                    endedBlock = macro
                    leaveBlock()
                else:
                    error('Macro "%s" within unhandled block %s...' %
                          (macro, cB))
                continue

            # -----------------------------------------------------------------
            # Match for appendix
            # currently: appendix must be LAST element, no 'end' statement
            #            this is added at end of document, if app exists
            Match = _APP_.match(line)
            if Match:
                if haveAppendix:
                    error('APP statement must only be specified ONCE...')
                    sys.exit(1)
                macro = validateMacro(Match.group('MACRO'))
                todo('Appendix needs some more work...')
                docBody.append('\\newpage\n\\begin{appendix}')
                haveAppendix = 1
                continue

            # -----------------------------------------------------------------
            # Match for 'page break' BRK or 'newline' NL or 'paragraph' NP
            Match = _BRK_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                if macro == 'BRK':
                    docBody.append('\\newpage\n')
                elif macro == 'NL':
                    #if not isInList and not heading:
                    if not isInList and not heading and not endedBlock:
                        docBody.append('\\newline')
                    elif isInList:
                        if len(llxStack) > 2:
                            warn('File included immediately after a List starts '
                                 'with %%NL which is not allowed immediately '
                                 'after a %%L list statement - ignoring the NL')
                        else:
                            warn('%%NL not allowed immediately after/within List - '
                                 'skipping, but you should remove the NL...')
                        isInList = 0
                    elif endedBlock:
                        warn('%%NL not allowed immediately after end of "%s" - '
                             'skipping, but you should remove the NL...' %
                             endedBlock)
                    else:
                        if len(llxStack) > 2:
                            warn('File included immediately after a Heading starts '
                                 'with %%NL which is not allowed immediately '
                                 'after a heading - ignoring the NL')
                        else:
                            warn('%%NL not allowed immediately after Heading - '
                                 'skipping, but you should remove the NL...')
                        heading = 0
                # PAR BREAK
                elif macro == 'NP':
                    docBody.append('')
                else:
                    error('Bad macro found: %s' % macro)
                continue

            # -----------------------------------------------------------------
            # Match for footnote
            Match = _FOOT_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                if Match.group('CONTENT'):
                    content = Match.group('CONTENT')
                    content = re.sub(r'\\', r'\\textbackslash{}', content)
                    content = re.sub(r'([_&%$#])', esc, content)
                    docBody.append('\\footnote{%s}' % content)
                else:
                    warn('Footnote without text content')
                continue

            # -----------------------------------------------------------------
            # Match for HREF
            # TODO: check for valid url and put in http if needed ??
            # \href{http://www.google.de}{\textbf{\texttt{www.google.de}}}
            # use '\\allowbreak ' after each slash within the text display
            # %28=(, %29=)
            # TODO: test with most complex urls
            # TODO: missing http:// will try to link to file:// - warn and add
            #       automatically
            Match = _HREF_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                urltext = Match.group('URL')
                if urltext:
                    debug('Match HREF: %s' % urltext)
                    linktext = Match.group('TEXT')
                    if not linktext:
                        linktext = re.sub(r'([#_%&])', esc, urltext)
                    linktext = re.sub('%2[089]', ' ', linktext)
                    linktext = re.sub('/', '/\\\\allowbreak ', linktext)
                    linktext = re.sub('-', '-\\\\allowbreak ', linktext)
                    linktext = re.sub('_', '_\\\\allowbreak ', linktext)
                    linktext = re.sub('=', '=\\\\allowbreak ', linktext)
                    linktext = re.sub('\.', '.\\\\allowbreak ', linktext)
                    linktext = re.sub('(\$)([^\s,\.}]+)', makeVar, linktext)
                    linktext = re.sub('\$', '\\\$', linktext)
                    if isHidden:
                        docBody.append('\hypersetup{urlcolor=hhref}')
                    docBody.append('\href{%s}'
                                   #'{\\textbf{\\texttt{%s}}}' %
                                   '{\\small{\\textbf{\\texttt{%s}}}}' %
                                   (urltext, linktext))
                    if isHidden:
                        docBody.append('\hypersetup{urlcolor=href}')
                else:
                    warn('HREF without link content')
                # TODO: recheck this. Added to avoid error on %%NL after end
                #       of V - endedBlock was still "V"
                # Now: HREF after H1: produces stacked heading...
                if endedBlock:
                    endedBlock = None
                continue

            # -----------------------------------------------------------------
            # Match for literature
            # \begin{thebibliography}{n}
            # \bibitem{myname}
            # \end{thebibliography}
            # TODO: lit should not be allowed within included llx file - check!
            #       same for appendix - macro not allowed in included file..
            Match = _LIT_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                if not haveAppendix:
                    error('LIT statement only allowed in APPENDIX...')
                    sys.exit(1)
                cB = getCurrentBlock()
                if cB is None:
                    debug('Entering "%s" block' % macro)
                    docBody.append('\\begin{thebibliography}{99}')
                    enterBlock(macro)
                elif cB == macro:
                    debug('Leaving "%s" block' % macro)
                    docBody.append('\\end{thebibliography}')
                    leaveBlock()
                else:
                    error('Macro "%s" within unhandled block %s...' %
                          (macro, cB))
                continue

            # -----------------------------------------------------------------
            # Match for landscape format
            # TODO: here we need the currentblock stack, if table inside!!!
            Match = _LAND_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                cB = getCurrentBlock()
                if cB is None:
                    debug('Entering landscape mode')
                    docBody.append('\\begin{landscape}')
                    enterBlock(macro)
                elif cB == macro:
                    debug('Leaving landscape mode')
                    docBody.append('\\end{landscape}\n'
                                   '\\noindent')
                    leaveBlock()
                else:
                    error('Macro "%s" within unhandled block %s...' %
                          (macro, cB))
                continue

            # -----------------------------------------------------------------
            # Match for private comment block
            # Will be hidden in PDF, if not specifying --private option
            Match = _PRIV_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                cB = getCurrentBlock()
                if cB is None:
                    if options.private:
                        info('Entering "%s" block' % macro)
                        docBody.append('\\definecolor{shadecolor}{rgb}'
                                       '{1.00,0.80,0.80}\n'
                                       '\\begin{shaded}\n'
                                       '\\noindent\n'
                                       '\\footnotesize\n'
                                       '\\textcolor{black}{'
                                       '\\textbf{'
                                       'PRIVATE NOTICE - (only shown by '
                                       '--private option)'
                                       '}\\\\')
                    else:
                        info('Skipping "%s" block - use --private option to '
                             'process' % macro)
                    enterBlock(macro)
                elif cB == macro:
                    if options.private:
                        debug('Leaving "%s" block' % macro)
                        docBody.append('}\n'
                                       '\\end{shaded}\n'
                                       '\\definecolor{shadecolor}{rgb}'
                                       '{0.95,0.95,0.95}\n'
                                       #'%s\n'
                                       #'\\noindent' % fsize[defFontSize])
                                       '%s\n' % fsize[defFontSize])
                        endedBlock = macro
                    else:
                        info('End of skipped "%s" block' % macro)
                    leaveBlock()
                else:
                    error('Macro "%s" within unhandled block %s...' %
                          (macro, cB))
                continue

            # -----------------------------------------------------------------
            # Match for private comment block - alternativce version
            # Is hidden in PDF, if not explicitly seleted by --private option
            # shadecolor is given name for shaded, redefine from verbose color
            # to priv and back
            # \definecolor{shadecolor}{rgb}{0.90,0.90,0.90}
            # \definecolor{priv}{rgb}{0.75,0.00,0.00}
            Match = _HIDE_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                cB = getCurrentBlock()
                if cB != macro:
                    if options.unhide:
                        continue
                    if options.private:
                        info('Entering "%s" block' % macro)
                    else:
                        info('Skipping "%s" block (no --private/--unhide)' %
                             macro)
                    isHidden = 1
                    enterBlock(macro)
                elif cB == macro:
                    if options.private:
                        info('Leaving "%s" block' % macro)
                    else:
                        info('End of skipped "%s" block' % macro)
                    isHidden = 0
                    leaveBlock()
                else:
                    error('Macro "%s" within unhandled block %s...' %
                          (macro, cB))
                continue

            # -----------------------------------------------------------------
            # Match for history entry
            Match = _HST_.match(line)
            if Match:
                macro = validateMacro(Match.group('MACRO'))
                cB = getCurrentBlock()
                if cB is None:
                    debug('Entering "%s" block' % macro)
                    enterBlock(macro)
                    line2print = 'Version & Date & Author &Comment'
                    docHistory.append(r'\\begin{filecontents*}{%s.hst}\n'
                                      r'\\rmfamily\\normalsize\n'
                                      r'\\begin{longtable}[c]{lllX}\n'
                                      r'\endfirsthead\n'
                                      r'\multicolumn{4}{c}%%\n'
                                      r'{{ '
                                      r'}} \\\\\n'
                                      r'\endhead\n'
                                      r'\multicolumn{4}{c}{{ '
                                      r'}} \\\\\n'
                                      r'\endfoot\n'
                                      r'\endlastfoot\n' % baseLtxFileName)
                elif cB == macro:
                    debug('Leaving "%s" block' % macro)
                    if hstNewComment:
                        hstauthor = author
                        if userName:
                            hstauthor = userName
                            debug('Replacing HST author info "%s" by "%s"' %
                                  (author, hstauthor))
                        docHistory.append(r'\nV %s & %s & %s & %s \\\\\n' %
                                          (docVersion,
                                           docdate.split(',')[1],
                                           hstauthor,
                                           hstNewComment))
                        haveHistory = 1

                    docHistory.append(r'\end{longtable}\n'
                                      r'\end{filecontents*}\n'
                                      r'\LTXtable{\\textwidth}{%s.hst}\n'
                                      r'\\noindent\n' % baseLtxFileName)
                    leaveBlock()
                else:
                    error('Macro "%s" within unhandled block %s...' %
                          (macro, cB))
                continue

            # -----------------------------------------------------------------
            # Match for comment in lalatex source
            Match = _CMT_.match(line)
            if Match:
                continue

            # -----------------------------------------------------------------
            # Match a RUN statement to execute some script or command
            # for now: only allowed for verbatim filling
            Match = _RUN_.match(line)
            if Match:
                if options.offline:
                    todo('offline option - will not run macro...')
                macro = validateMacro(Match.group('MACRO'))
                if Match.group('RUNCMD'):
                    runCmd = Match.group('RUNCMD')
                    debug('RUN: ' + runCmd)
                else:
                    error('Macro "%s": a command/script must be specified' %
                          macro)
                    sys.exit(1)

                if not Match.group('TIMEOUT'):
                    runTimeOut = 10
                    info('Macro "RUN" with no timeout, using %d sec default' %
                         runTimeOut)
                else:
                    runTimeOut = int(Match.group('TIMEOUT'))

                cB = getCurrentBlock()
                if not cB in ('V', 'TAB'):
                    error('Run command "%s" skipped - not in V or TAB' %
                          runCmd)
                    continue
                # offline data filename as hash of llx and command
                file4hash = (os.path.basename(os.path.normpath(os.getcwd())) +
                             '/' + llxStack[-1]['llxBase'] + '.llx')
                offlineFile = hashlib.md5(file4hash+runCmd).hexdigest()
                debug('File: "%s" + command: "%s" = "%s"' % (file4hash,
                                                             runCmd,
                                                             offlineFile))
                offlinePath = wrkDefaultDir + '/' + offlineFile
                # TODO: filtering some dangerous stuff like delete commands
                # TODO: parallelization with multiple workerthreads and queues?

                if not options.offline:
                    info('Starting thread for "%s" with timeout = %d sec' %
                         (runCmd, runTimeOut))
                    runFailed, StdOut, StdErr = RUN(runCmd).run(timeout=runTimeOut)
                else:
                    runFailed = 0

                if runFailed or options.offline:
                    if runFailed: 
                        error('Returned with failure from "%s" with rc = %d' %
                              (runCmd, runFailed))
                        for err in StdErr.split('\n'):
                            # TODO: splitlines() better...
                            if err:
                                info('"%%%%RUN %s" returned "%s"' %
                                     (runCmd, err))
                    # try to read from possible offline file
                    if os.path.exists(offlinePath):
                        if options.offline:
                            info('Using offline content in: "%s"' %
                                 offlinePath)
                        else:
                            warn('Using offline content in: "%s"' %
                                 offlinePath)
                        with open(offlinePath, 'r') as OFF:
                            StdOut = OFF.read()
                        addResource(os.path.abspath(offlinePath),
                                    llxStack[-1]['llx'],
                                    'rundata')
                    else:
                        if runFailed:
                            # TODO: here we could add info for empty verbatim
                            error('Also no matching offline content (%s)' %
                                 offlinePath)
                        if options.offline:
                            error('No offline content available (%s)' %
                                 offlinePath)
                            StdOut = ''
                else:
                    info('Returned from "%s" with rc = %d' %
                         (runCmd, runFailed))
                         #(runCmd,childProcess.returncode))
                    with open(offlinePath, 'w+') as OFF:
                        OFF.write(StdOut)
                    # TODO - error checking!!
                    addResource(os.path.abspath(offlinePath),
                                llxStack[-1]['llx'],
                                'rundata')
                lc = 1
                # here: check, if offline mode - then read from file, else
                # read from stdout content
                if cB == 'V':
                    # removing trailing empty lines - what about table?
                    StdOut = re.sub(r'\n$', '', StdOut)
                for line in StdOut.split('\n'):
                    devel('RunCmd: "%s"' % line)
                    if cB == 'V':
                        makeVerbatim(line)
                    elif cB == 'TAB':
                        # TODO: evaluate python csv package - we could read
                        # the offline file here !
                        # check for unicode issues with that!!
                        # see PEP 0305 for infos
                        if line:
                            line = chkEscape(line)
                            if not addTableWorkContents(line, tabData):
                                error('... above error is in line %d in '
                                      'output of "%%%%RUN %s" macro' %
                                      (lc, runCmd))
                    else:
                        error('RUN macro failure - bad block %s' % cB)
                    lc += 1
                continue

            # -----------------------------------------------------------------
            # ANYTHING ELSE IS CONSIDERED TO BE NORMAL TEXT.
            # Special situations have to be considered, anyway:
            # - evil characters (e.g. _)
            # - lalatex comments
            # - we are within an active table block (e.g. table)
            # - we are within literature block
            # - we are within a history block
            # - %% things: at least warn, if this is not a typo and actually
            #   was meant to be a lalatex keyword... otherwise it will be added
            #   as comment to the latex .tex file - (%% is the latex comment)

            cB = getCurrentBlock()
            if cB == 'HST':
                hstData = line.split('#')
                if len(hstData) != 4:
                    error('Bad history data found: %s' % line)
                    sys.exit(2)
                debug('History entry: %s, %s, %s, %s' %
                      (hstData[0], hstData[1], hstData[2], hstData[3]))
                docHistory.append(r'\nV %s & %s & %s & %s \\\\\n' %
                                  (hstData[0], hstData[1],
                                   hstData[2], hstData[3]))
                haveHistory = 1
                continue
            if cB == 'CODE':
                docBody.append(line)
                continue
            if cB == 'V':
                # using \verbatim and similar would be easier, but we want
                # nice bg color and NO empty line before and after.
                # BVerbatim allows this, but it cannot span page boundaries.
                # So go for \verb the hard way. this imposes some escaping
                # problems.
                # \verb|text erste zeile|
                # \\\verb|text rest|
                makeVerbatim(line)
                continue
            if cB == 'LIT':
                line = re.sub('_', '\_', line)
                Match = re.match('(\w+)#([\s\w]+)#(.+)', line)
                if Match:
                    debug('Bibitem: citename "%s", author "%s", Title "%s"' %
                          (Match.group(1), Match.group(2), Match.group(3)))
                    docBody.append('\\bibitem{%s} \\textsc{%s} \\textit{%s}' %
                                   (Match.group(1),
                                    Match.group(2),
                                    Match.group(3)))
                else:
                    error('Bibitem Entry with bad structure '
                          '(need citename#author#title)')
                continue
            if cB == 'TAB':
                if line:
                    if not re.match(r'^(\$\$|%%|SORTBY|COLORDER)', line):
                        addTableWorkContents(line, tabData)
                continue

            if line and not currentHeading:
                error('Text found at document begin: "%s" - first statment '
                      'must be a "H1" heading macro' %
                      line)
                sys.exit(1)

            if cB == 'PRIV' or isHidden:
                if options.private:
                    if isHidden:
                        docBody.append('\\color{texthidden}')
                    if endedBlock:
                        docBody.append('\\noindent')
                        endedBlock = None
                    line = processSingleCharBlocks(line)
                    docBody.append(line)
                    if isHidden:
                        docBody.append('\\color{black}')
                continue
            else:
                if line == '':
                    pass
                else:
                    if endedBlock:
                        docBody.append('\\noindent')
                        endedBlock = None
                    # code block for x{} processing, e.g. b{bold text}
                    line = processSingleCharBlocks(line)
                    docBody.append(line)
    # At end of document: all sections must be closed
    if len(llxStack) < 3:
        cB = getCurrentBlock()
        if cB == 'V':
            error('NON CLOSED VERBATIM BLOCK at end of file detected, check '
                  'for any warnings about potential unclosed verbatims')
            sys.exit(1)
        elif cB is not None:
            error('NON CLOSED "%s" BLOCK at end of file detected' % cB)
            sys.exit(1)
    debug('Returning from processLtx() "%s.llx"' %
          llxStack.pop()['llx'])
    vardict['LTXFILE'] = llxStack[-1]['llx']
    debug('LTX DEPTH LEVEL NOW BACK: %d' % (len(llxStack)-2))
    return

##########################################################################
######################## E N T R Y   P O I N T  ##########################
##########################################################################

welcome = ('\nWelcome to LaLaTeX\n'
           '==================\n\n'
           '\033[01;30m1.\033[0m New User? Create a PDF Users Guide:        '
           '\033[01;35mlalatex --makedoc [--show]\033[0m\n'
           '\033[01;30m2.\033[0m           Display the help                 '
           '\033[01;35mlalatex -h \033[0m\n'
           '\033[01;30m3.\033[0m If you want to create a new document, run: '
           '\033[01;35mlalatex --new filename (no filetype)\033[0m\n'
           '   in a working directory for your project\n'
           '\033[01;30m4.\033[0m To compile an existing .llx file, run:     '
           '\033[01;35mlalatex filename [--show] [--viewer]\033[0m\n'
           '\n"filename": the base name for the set of files that are '
           'created, without any extension\n'
           '\nHave FUN\n')

usage = 'Usage: %prog [option] <filename>' + welcome

# TODO: add option like --makeinc for nested docs
#       move from optparse to argparse...
parser = OptionParser(usage=usage)
parser.add_option('-t', '--timeout',
                  type='int',
                  dest='timeout',
                  default=45,
                  help='Timeout, default 45 sec'
                  )
parser.add_option('-v', '--verbose',
                  dest='verbose',
                  action='store_true',
                  help='Produce verbose output'
                  )
parser.add_option('-V', '--version',
                  dest='version',
                  action='store_true',
                  help='Display version'
                  )
parser.add_option('-d', '--debug',
                  dest='debug',
                  action='store_true',
                  help='Produce debug output'
                  )
parser.add_option('', '--devel',
                  dest='devel',
                  action='store_true',
                  help='For development only, same as showDevel=1'
                  )
parser.add_option('-k', '--keep',
                  dest='keep',
                  action='store_true',
                  help='Keep the temporary files created during processing'
                  )
parser.add_option('-e', '--export',
                  dest='export',
                  action='store_true',
                  help='Export the files used in this project into a tarball'
                  )
parser.add_option('-i', '--import',
                  type='string',
                  dest='importfile',
                  default='',
                  help='Import content from a project tarball'
                  )
parser.add_option('-n', '--new',
                  dest='new',
                  action='store_true',
                  help='Create a new project including an .llx skeleton'
                  )
parser.add_option('', '--history',
                  dest='history',
                  action='store_true',
                  help='Add a document history entry above Table of Contents'
                  )
parser.add_option('-m', '--makedoc',
                  dest='makedoc',
                  action='store_true',
                  help='Create the Users Guide PDF in the current directory'
                  )
parser.add_option('-s', '--show',
                  dest='showpdf',
                  action='store_true',
                  help='Optionally open the PDF after creation (default viewer'
                       ' evince or ocular, depending on your desktop)'
                  )
parser.add_option('', '--viewer',
                  type='string',
                  dest='pdfviewer',
                  default='evince',
                  help='Optionally specify another PDF viewer with --show'
                  )
parser.add_option('-p', '--private',
                  dest='private',
                  action='store_true',
                  help='Include private notices and hidden parts in the PDF'
                  )
parser.add_option('', '--unhide',
                  dest='unhide',
                  action='store_true',
                  help='Include hidden parts without marking them as hidden'
                  )
parser.add_option('-o', '--offline',
                  dest='offline',
                  action='store_true',
                  help='Skip RUN macros and try to use offline data only'
                  )
(options, args) = parser.parse_args()

todo('move from optparse to argparse...')

# The user name
userName = getFullUserName()
if userName:
    debug('Running with User Name "%s"' % userName)
    author = userName
else:
    warn('Your name could not be resolved, did you open your session as root?')

if options.version:
    print('This is LaLaTeX version %s' % lalatexVersion)
    tStamp = time.strftime("%Y-%m-%d-%H-%M-%S")
    sys.exit(0)

if options.devel:
    showDevel = 1

# why not move the pkgmgr check from top to here ?
if pkgMgr:
    fail = None
    # the os-release file, that comes as part of systemd
    releaseFile = '/etc/os-release'

    # Do more special checks, if the pkgs under 'rpm' or 'apt'
    # are not sufficient, e.g. opensuse failed, need the extra
    # package for watermark.
    # on the other hand: avoid installing packages, that are
    # not available for a distro
    infos = getOsRelease()
    if infos:
        devel('Infos from  getOsRelease()', infos)
        if 'PRETTY_NAME' in infos.keys():
            pname = infos['PRETTY_NAME']
            info('Detected OS: %s' % pname)
            if re.match(r'"*Fedora.*', pname):
                if 'VARIANT_ID' in infos.keys():
                    variant = infos['VARIANT_ID']
                    debug('Detected Fedora VARIANT_ID: "%s"' % variant)
                else:
                    variant = 'workstation'
                    warn('No Fedora VARIANT_ID, assuming: "%s"' % variant)
                pkgMgr = pkgMgr + '-Fedora-' + variant
                debug('Using prereq pkgmgr key: "%s"' % pkgMgr)
            if re.match(r'"*openSUSE.*', pname):
                if 'ID' in infos.keys():
                    id = infos['ID']
                    debug('Detected openSUSE ID: "%s"' % id)
                else:
                    id = 'opensuse'
                    warn('No openSUSE ID, assuming: "%s"' % id)
                pkgMgr = pkgMgr + '-' + id
                debug('Using prereq pkgmgr key: "%s"' % pkgMgr)
            if re.match(r'"*CentOS.*', pname):
                if 'ID' in infos.keys():
                    id = re.sub(r'"', '', infos['ID'])
                    debug('Detected CentOS ID: "%s"' % id)
                else:
                    id = 'centos'
                    warn('No CentOS ID, assuming: "%s"' % id)
                pkgMgr = pkgMgr + '-' + id
                debug('Using prereq pkgmgr key: "%s"' % pkgMgr)
        else:
            warn('No PRETTY_NAME key in %s' % releaseFile)

    else:
        error('not found')

    missingPkgs = []
    # TODO: make code clean: first check, if the key exists!!!!
    if pkgMgr in prereqs.keys():
        for pkg in prereqs[pkgMgr]:
            if checkPkg(pkg) != 0:
                missingPkgs.append(pkg)
                fail = 1
    else:
        error('Bad key "%s" for lookup in package prereqs' % pkgMgr)
        # TODO: just stoppin here, but maybe other options?
        sys.exit(1)

    if fail:
        print('\033[91mERROR:  \033[0m The following required packages are '
              'not installed:\n%s' % ' '.join(missingPkgs))
        exit(1)

    # check for other pkgs that might be needed
    haveMagick = 0
    if checkPkg('ImageMagick') == 0:
        haveMagick = 1
else:
    exit(1)

# The common lalatex directory and the working directories within currentdir
commondir = prepareCommonDir(llxsubdir, (defLeftLogo,))
if not options.importfile:
    createDirs((srcDefaultDir, tabDefaultDir, imgDefaultDir, wrkDefaultDir))

# Check for modules used in future - python magic for script type detection
try:
    import magic
    debug('Found python magic package available')
except ImportError:
    debug('Found python magic package not installed')

if options.importfile:
    if os.path.exists(options.importfile):
        importProjectTarball(options.importfile)
    else:
        error('File "%s" not found' % options.importfile)
        sys.exit(1)
    sys.exit(0)

if options.private:
    warn('Flag --private specified: PDF will contain private comments and '
         'hidden parts (highlighted)')

if options.unhide:
    warn('Flag --unhide specified: PDF will contain hidden parts '
         '(NOT highlighted)')

if options.makedoc:
    ugName = 'LaLaTeX_Users_Guide-v%s' % lalatexVersion
    ugLtx = 'LaLaTeX_Users_Guide.llx'
    if os.path.exists(ugLtx):
        warn('Overwriting existing "%s"'
             % ugLtx)
    lalaDoc = re.sub('\$AUTH\$', '$AUTH$ ' + 'Herbert Mehlhose', lalaDoc)
    lalaDoc = re.sub('\$TITLE\$', '$TITLE$ LaLaTeX Users Guide (Version %s)' %
                     lalatexVersion, lalaDoc)
    lalaDoc = re.sub('\$VERS\$', '$VERS$ %s' % lalatexVersion, lalaDoc)
    lalaDoc = re.sub('\$COMMONDIR\$', commondir, lalaDoc)
    lalaDoc = re.sub('\$SMPTAB\$',
                     makeSampleTable('Available colors for table highlighting',
                                     'hlcolors',
                                     50),
                     lalaDoc)
    with open(ugLtx, 'w') as LTX:
        LTX.write(lalaDoc)
    # check for local copy of lalatex called from within current dir
    if sys.argv[0] == './lalatex':
        executable = '%s/lalatex' % os.getcwd()
    else:
        executable = 'lalatex'
    info('Recursively calling %s for %s' % (executable, ugName))
    if options.debug:
        out = subprocess.Popen([executable,
                               '--private',
                               ugName,
                               '--history',
                               ('Documentation PDF created by running lalatex '
                                '--makedoc -d')],
                               stderr=subprocess.PIPE).communicate()
    else:
        out = subprocess.Popen([executable,
                               '--private',
                               ugName,
                               '--history',
                               ('Documentation PDF created by running lalatex '
                                '--makedoc')],
                               stderr=subprocess.PIPE).communicate()
    # TODO: Check for failures
    print ('A new Users Guide "%s" has been created' % (ugName+'.pdf'))
    print ('\n\033[1;31m==== IMPORTANT! ====\nThe above errors/warnings are '
           'intentional, because the documentation\ncontains some error '
           'examples for demonstration purpose.\033[0m\n')
    if options.showpdf:
        showPdf(ugName+'.pdf', options.pdfviewer)
    sys.exit(0)

if len(args) == 0:
    print(welcome)
    exit(1)

#if options.verbose:
#    todo('Option --verbose still needs to be implemented')

if options.history:
    # Entering a comment here: the source document is changed and
    # gets appended this information along with author, version and timestamp.
    # This is a cumulative process.
    # TODO - what if no content given?
    hstNewComment = ' '.join(args[1:])
    info('History information to add: "%s"' % hstNewComment)
else:
    hstNewComment = None

if options.new:
    if len(args) < 1:
        print '--new option needs a new file base...'
        sys.exit(2)
    if re.match('.+\.llx', args[0]):
        newLtx = args[0]
    else:
        newLtx = args[0] + '.llx'
    if os.path.exists(newLtx):
        error('Cannot create "%s", this object already exists.'
              % newLtx)
        exit(1)
    else:
        lalaSkeleton = re.sub('\$LALATEX\$', lalatexVersion, lalaSkeleton)
        lalaSkeleton = re.sub('\$AUTH\$', '$AUTH$ ' + author, lalaSkeleton)
        lalaSkeleton = re.sub('\$COMMONDIR\$', commondir, lalaSkeleton)
        with open(newLtx, 'w+') as LTX:
            LTX.write(lalaSkeleton)
        print 'New document file %s has been created' % newLtx
    print('You can now edit %s and then run "lalatex %s [-d] [--show] '
          '[--viewer]"' % (newLtx, newLtx.split('.', 1)[0]))
    print('This creates a pdf file. With --show, the file is displayed using '
          'evince or okular')
    print('by default, but you may specifiy other viewers with --viewer, e.g. '
          'acroread')
    print('The -d flag is a debug flag')
    sys.exit(1)

# signal processing
signal.signal(signal.SIGALRM, handler)
#signal.alarm(options.timeout)
signal.signal(signal.SIGTERM, handler)

# baseLtxFileName: the name of the main llx file passed as argument
# this determines the final document name!
# currentLtxFileName: might change during INC for llx files
# TODO: put into one single regex !!!
baseLtxFileName = args[0]
if re.match('.+\.llx', baseLtxFileName):
    debug('Processing %s' % baseLtxFileName)
    warn('Please enter name without file extension, '
         'removing ".llx" from "%s" for you now' %
         baseLtxFileName)
    baseLtxFileName = re.sub('.llx', '', baseLtxFileName)
Match = re.match('.+(-v[\.\d]+)', baseLtxFileName)
if Match:
    debug('Processing %s' % baseLtxFileName)
    warn('Please enter name without version numbers, '
         'removing "%s" from "%s" for you now' %
         (Match.group(1), baseLtxFileName))
    baseLtxFileName = re.sub(Match.group(1), '', baseLtxFileName)
currentLtxFileName = baseLtxFileName
# working variables
# TODO: maybe better move up
# code for llx include: recursive function processLtx()
# - parameters: processLtx(llx file name w/o ending)
# - keep stack for information
llxStack.append({'llx': os.path.abspath(currentLtxFileName + '.llx'),
                 'llxBase': currentLtxFileName,
                 'logName': currentLtxFileName + '.llx',
                 'llxLineNum': 0,
                 'llxTabCount': 0})

currentLtxFile = currentLtxFileName + '.llx'
docVersion = ''
versionedFileName = ''
currentBlock = []     # keep track of block we are in in a stack
workList = []         # used for lists (Lx)
workVerbatim = []     # used for verbatim sections (Vx)
workTableList = []    # used for table data with no sorting
defCsvSep = ';'       # default separator for csv data to fill tables
tabSortBy = ''        # for table sorting feature
tabColSort = ''       # for table column sorting feature
tablecol = 0          # counter for table columns
tabfont = ffamily[defTabFont]
tabfontsize = fsize[defTabFontSize]
tabFileContents = ''  # temp filename for filecontents in tables
llxTables = hfcmDict()
tabcount = 0          # overall tables in document (with included llx)
tabcolors = ['white', 'lblue']       # for alternating rows ('A' Flag)
tabcolorshidden = ['white', 'lred']  # alternating rows in hidden
caption = ''          # temp variable for caption content
captions = {}         # key: caption, content: linenumber
labels = hfcmDict()   # key: labeltext, content: the ref string
haveAppendix = 0
haveHistory = 0       # do we have %%HST statements'?
currentHeading = 0    # keep track of current heading level
customer = ''         # Fallback for missing logo
imgcount = 0          # index for images in document
heading = 0           # for checking stacked headlines
hrefs = {}            # keep track of web links: key = URL
isHidden = 0
isInList = 0          # for detection of %%NL after %L
endedBlock = None     # block just ended - bad %%NL detection
vFontSize = 'hugo'
usedResources = hfcmDict()
# TODO: use \textbraceleft and \textbraceright - test it
pCurly = {'{': '--<--', '}': '-->--'}

# labels: ch: chapter, sec: section, subsec: subsection, fig: figure
#         tab: table, eq: equation, lst: codelisting, itm: enum list item
#         alg: algorithm, app: appendix subsection

# Precompiled regex go here
# TODO - the %%macros - add ^ to regex to start at line beginning!!
#        and intensive testing needed (best: diff to produced tex)
# $VAR - changed to avoid spaces in between $VAR$, e.g. $text here $
#_VAR_   = re.compile('\$(?P<VARNAME>.+)\$\s*'
_VAR_ = re.compile('^\$(?P<VARNAME>\S+)\$\s*'
                   '(?P<VALUE>.*)')
_H_ = re.compile('%%(?P<MACRO>H)'
                 '(?P<LEVEL>[0-5]{1})\s*'
                 '(?P<CONTENT>.*)')
# Fails if no space between macro/type and content
_L_ = re.compile('%%(?P<MACRO>[Ll])'
                 '(?P<TYPE>[\w\!\"]?)\s+'
                 '(?P<CONTENT>.+)')
_V_ = re.compile('%%(?P<MACRO>[Vv])'
                 '(?P<FONTSIZE>[0-9]{0,1})\s*')
_TAB_ = re.compile('%%(?P<MACRO>TAB)'
                   '(?P<FLAGS>\S*)\s*'
                   '(?P<CAPTION>[^#]*)#*'
                   '(?P<LABEL>.*)')
_INC_ = re.compile('%%(?P<MACRO>INC)\s*'
                   '(?P<INCFILE>[\w.\-/]*)\s*')
_RUN_ = re.compile('%%(?P<MACRO>RUN)'
                   '(?P<TIMEOUT>\d*)\s*'
                   '(?P<RUNCMD>[^#]*)#*\.*')
_IMG_ = re.compile('%%(?P<MACRO>IMG)'
                   '(?P<SIZE>\d*)\s*'
                   '(?P<IMGFILE>[^#]*)#*'
                   '(?P<CAPTION>[^#]*)#*'
                   '(?P<LABEL>.*)')
_SRC_ = re.compile('%%(?P<MACRO>SRC)\s*'
                   '(?P<PATH>[\w./-]*)\s*')
_CODE_ = re.compile('%%(?P<MACRO>CODE)'
                    '(?P<FONTSIZE>[0-9]*)[\s#]*'
                    '(?P<LANG>\w*)#*'
                    '(?P<CAPTION>[\(\)\s\w.]*)#*'
                    '(?P<LABEL>[\s\w.]*)')
_NOTE_ = re.compile('%%(?P<MACRO>NOTE|WARN|TIP|TODO)'
                    '(?P<FONTSIZE>[0-9]?)\s*'
                    '(?P<CONTENT>.*)')
_APP_ = re.compile('%%(?P<MACRO>APP)\s*')
_BRK_ = re.compile('%%(?P<MACRO>BRK|NL|NP)')
_FOOT_ = re.compile('%%(?P<MACRO>FOOT)\s*(?P<CONTENT>.*)')
_HREF_ = re.compile('%%(?P<MACRO>HREF)\s*'
                    '(?P<URL>[^\s]*)\s*'
                    '(?P<TEXT>.*)')
_LIT_ = re.compile('%%(?P<MACRO>LIT)')
_LAND_ = re.compile('%%(?P<MACRO>LAND)')
_PRIV_ = re.compile('%%(?P<MACRO>PRIV)')
_HIDE_ = re.compile('%%(?P<MACRO>HIDE)')
_HST_ = re.compile('%%(?P<MACRO>HST)')
_CMT_ = re.compile('\$\$(.*)')

# Table TighLight macros 0-9
_THL_ = re.compile('(^|\s*)(\d{1}){([^}]+)}')

docdate = time.strftime("%A, %d.%m.%Y, %H:%M:%S")
tStamp = time.strftime("%Y-%m-%d-%H-%M-%S")
docHead = re.sub('\$DATE\$', docdate, docHead)

# A preamble to be written to the produced .tex file.
preamble = '''\
%% Document generated by lalatex, Version %s, written by Herbert Mehlhose
%% Date: %s
''' % (lalatexVersion, docdate)

# Used by validateMacro(): Which macros are forbidden within which blocks?
# 'forbidden': ('within','these','blocks')
forbidden = {
'IMG': ('V', 'CODE', 'NOTE', 'WARN', 'TIP', 'TODO', 'TAB', 'LIT'),
'SRC': ('V', 'CODE', 'NOTE', 'WARN', 'TIP', 'TAB'),
'TAB': ('V', 'CODE', 'NOTE', 'WARN', 'TIP', 'TODO'),
'APP': ('V', 'CODE', 'NOTE', 'WARN', 'TIP', 'TODO', 'TAB'),
'BRK': ('V', 'CODE', 'NOTE', 'WARN', 'TIP', 'TODO', 'TAB'),
'NL': ('V', 'PRIV', 'CODE', 'TAB', 'SRC', 'CODE'),
'NP': ('V', 'PRIV', 'CODE', 'TAB', 'SRC', 'CODE'),
'LIT': ('CODE', 'NOTE', 'WARN', 'TIP', 'TODO', 'PRIV', 'TAB'),
'FOOT': ('V', 'CODE'),
'HREF': ('V', 'CODE'),
'PRIV': ('HIDE', 'CODE'),
'H': ('V', 'TODO', 'WARN', 'TIP', 'NOTE', 'CODE', 'TAB'),
'CODE': ('V', 'TODO', 'WARN', 'TIP', 'NOTE', 'TAB'),
'L': ('V', 'SRC', 'TODO', 'CODE', 'NOTE', 'WARN', 'TIP', 'TAB'),
'V': ('SRC', 'TODO', 'CODE', 'NOTE', 'WARN', 'TIP', 'TAB', 'PRIV')
}

# Used by verbatim \verb to select an appropriate escape character
# used with verbatimline in makeVerbatim()
verbatimline = 0
verbatimcount = 0
warnV = 0
vescape = ('|', '~', '$', '%', '?')

# TODO - catch this, if file not found - needs one more indent
if not os.path.exists(currentLtxFile):
    print ('\033[91mERROR:  \033[0m File "%s" does not exist.'
           ' Use --new to create or check filename'
           % currentLtxFile)
    sys.exit(1)

# Start processing of llx input file at this point
processLtx(currentLtxFile)

# write LaTeX source file in 3 main sections: head + body + ending
info('Doing postprocessing...')
# TODO: check this versioning in name
texOutFileName = '%s.tex' % versionedFileName
# TODO: possible line number display within tex file during postprocess
llxStack[-1]['logName'] = texOutFileName
#with open ( texOutFileName, 'w+' ) as TEX:
with codecs.open(texOutFileName, 'w+', encoding='utf-8') as TEX:
    docHead = re.sub('\$PREAMBLE\$', preamble, docHead)
    docHead = re.sub('\$WATERMARK\$', '', docHead)
    if haveHistory:
        debug('Inserting Document History...')
        docHead = re.sub('\$DOCHISTORY\$', '\n'.join(docHistory), docHead)
    else:
        docHead = re.sub('\$DOCHISTORY\$', '', docHead)
    if imgcount == 0:
        debug('No Images, so removing list of figures...')
        docHead = re.sub('\\\\listoffigures\\n', '', docHead)
    if tabcount == 0:
        debug('No tables, so removing list of tables...')
        docHead = re.sub('\\\\listoftables\\n', '', docHead)
    TEX.write(docHead)
    llxStack[-1]['llxLineNum'] = len(docHead.split('\n')) + 2

    # Run through the docBody and perform POSTPROCESSING
    # - references creation (now with mkRef instead of makeRefs)
    # - escaped curly bracket creation
    # - variables from included llx files
    devel('Using the following labels structure', labels)
    for line in docBody:
        #if not re.match(r'^\\+verb.',line) and not 'bibitem' in line:
        if not re.match(r'^\\+verb.', line):
            line = re.sub(r'((^|\s+)[r]{[#\\\/\.\=\-\w\s\\&\(\)]*}?)',
                          mkRef,
                          line)
        # Regenerate masked curly brackets as escaped ones
        line = re.sub(pCurly['{'], r'\{', line)
        line = re.sub(pCurly['}'], r'\}', line)
        # Check for variables from llx includes used BEFORE the INC
        # that could not yet be resolved
        #if 'The Jump' in line or 'Anhalter' in line:
        #    pdb.set_trace()
        line = re.sub(r'(\\\$)([^\s,\.}]+)', makeVar, line)

        TEX.write(line + '\n')
        #TEX.write(line.encode('utf-8') + '\n')
        llxStack[-1]['llxLineNum'] += 1
    # reset line number - avoid filename in messages
    llxStack[-1]['llxLineNum'] = 0
    if haveAppendix:
        TEX.write('\\end{appendix}\n\\end{document}')
    else:
        TEX.write('\\end{document}')

print('Finished creating "%s"' % texOutFileName)
if not 'LaLaTeX' in currentLtxFile:
    print('Creating versioned copy of "%s" into "%s.llx"' %
         (currentLtxFile, versionedFileName))
    shutil.copy2(currentLtxFile, versionedFileName + '.llx')

# rewrite llx in case of new history entry --history was specified
# we read the llx and add %HST entries, if required.
if hstNewComment:
    info('Adding history comment: %s' % hstNewComment)
    rewriteLtx()

# devel('The llxTables structure dump',llxTables)
#devel('Table highlighting structure:',tabHLight)

# Tarball export - this ends the program, no PDF build
if options.export:
    exportProjectTarball()
    sys.exit(0)

# create PDF from this
chgFlag = 1
if os.path.exists(currentLtxFileName + '.bak'):
    md5bak = hashlib.md5(open(currentLtxFileName + '.bak', 'rb').read()).hexdigest()
    md5llx = hashlib.md5(open(currentLtxFileName + '.llx', 'rb').read()).hexdigest()
    debug('MD5 backup: %s, MD5 orig: %s' % (md5bak, md5llx))
    if md5llx == md5bak:
        info('No changes in llx file, not touching any backup versions...')
        chgFlag = 0
# register the timeout handler here
info('Setting timeout to %d seconds' % options.timeout)
signal.alarm(options.timeout)
try:
    if makePdf(versionedFileName) != 0:
        sys.exit(1)
except TimeOutException:
    error('makePdf timed out after %d seconds - try longer timeout '
          'and/or check the produced .tex file' % options.timeout)
    sys.exit(1)

# If PDF create ok, process backup files
if chgFlag:
    debug('Processing backup files, bak > bk2, llx > bak')
    if os.path.exists(currentLtxFileName + '.bak'):
        shutil.copy2(currentLtxFileName + '.bak', currentLtxFileName + '.bk2')
    shutil.copy2(currentLtxFileName + '.llx', currentLtxFileName + '.bak')

if not options.keep:
    cleanup()
else:
    debug('Skipping cleanup() of temporary files.')

# display PDF if --show option used
if options.showpdf:
    signal.alarm(0)
    showPdf(versionedFileName + '.pdf', options.pdfviewer)

#devel('Tab Highlighting, will have macros and table flag',tabHLight)
devel('Labels structure', labels)
devel('Table highlighting structure:', tabHLight)
devel('Variable dict structure:', vardict)
#devel('TODO ITEMS', todoItems)
devel('used resources', usedResources)
devel('llxTables', llxTables)

exit()
